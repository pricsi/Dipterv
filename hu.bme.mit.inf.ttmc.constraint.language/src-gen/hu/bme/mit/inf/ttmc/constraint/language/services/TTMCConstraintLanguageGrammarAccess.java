/*
 * generated by Xtext
 */
package hu.bme.mit.inf.ttmc.constraint.language.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class TTMCConstraintLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ConstraintSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstraintSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSpecificationKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParameterDeclarationsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_0_0 = (RuleCall)cParameterDeclarationsAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParameterDeclarationsAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_1_1_0 = (RuleCall)cParameterDeclarationsAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cTypeDeclarationsAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cTypeDeclarationsTypeDeclarationParserRuleCall_4_0_0 = (RuleCall)cTypeDeclarationsAssignment_4_0.eContents().get(0);
		private final Assignment cConstantDeclarationsAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cConstantDeclarationsConstantDeclarationParserRuleCall_4_1_0 = (RuleCall)cConstantDeclarationsAssignment_4_1.eContents().get(0);
		private final Assignment cFunctionDeclarationsAssignment_4_2 = (Assignment)cAlternatives_4.eContents().get(2);
		private final RuleCall cFunctionDeclarationsFunctionDeclarationParserRuleCall_4_2_0 = (RuleCall)cFunctionDeclarationsAssignment_4_2.eContents().get(0);
		private final Assignment cBasicConstraintDefinitionsAssignment_4_3 = (Assignment)cAlternatives_4.eContents().get(3);
		private final RuleCall cBasicConstraintDefinitionsBasicConstraintDefinitionParserRuleCall_4_3_0 = (RuleCall)cBasicConstraintDefinitionsAssignment_4_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/////////////////////////////////////////////
		//ConstraintSpecification:
		//	"specification" name=ID ("(" (parameterDeclarations+=ParameterDeclaration (","
		//	parameterDeclarations+=ParameterDeclaration)*)? ")")? "{" (typeDeclarations+=TypeDeclaration |
		//	constantDeclarations+=ConstantDeclaration | functionDeclarations+=FunctionDeclaration |
		//	basicConstraintDefinitions+=BasicConstraintDefinition)* "}";
		@Override public ParserRule getRule() { return rule; }

		//"specification" name=ID ("(" (parameterDeclarations+=ParameterDeclaration (","
		//parameterDeclarations+=ParameterDeclaration)*)? ")")? "{" (typeDeclarations+=TypeDeclaration |
		//constantDeclarations+=ConstantDeclaration | functionDeclarations+=FunctionDeclaration |
		//basicConstraintDefinitions+=BasicConstraintDefinition)* "}"
		public Group getGroup() { return cGroup; }

		//"specification"
		public Keyword getSpecificationKeyword_0() { return cSpecificationKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//("(" (parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)? ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//(parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_2_1_0() { return cParameterDeclarationsAssignment_2_1_0; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_2_1_0_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_0_0; }

		//("," parameterDeclarations+=ParameterDeclaration)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }

		//","
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_2_1_1_1() { return cParameterDeclarationsAssignment_2_1_1_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_2_1_1_1_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//(typeDeclarations+=TypeDeclaration | constantDeclarations+=ConstantDeclaration |
		//functionDeclarations+=FunctionDeclaration | basicConstraintDefinitions+=BasicConstraintDefinition)*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//typeDeclarations+=TypeDeclaration
		public Assignment getTypeDeclarationsAssignment_4_0() { return cTypeDeclarationsAssignment_4_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationsTypeDeclarationParserRuleCall_4_0_0() { return cTypeDeclarationsTypeDeclarationParserRuleCall_4_0_0; }

		//constantDeclarations+=ConstantDeclaration
		public Assignment getConstantDeclarationsAssignment_4_1() { return cConstantDeclarationsAssignment_4_1; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationsConstantDeclarationParserRuleCall_4_1_0() { return cConstantDeclarationsConstantDeclarationParserRuleCall_4_1_0; }

		//functionDeclarations+=FunctionDeclaration
		public Assignment getFunctionDeclarationsAssignment_4_2() { return cFunctionDeclarationsAssignment_4_2; }

		//FunctionDeclaration
		public RuleCall getFunctionDeclarationsFunctionDeclarationParserRuleCall_4_2_0() { return cFunctionDeclarationsFunctionDeclarationParserRuleCall_4_2_0; }

		//basicConstraintDefinitions+=BasicConstraintDefinition
		public Assignment getBasicConstraintDefinitionsAssignment_4_3() { return cBasicConstraintDefinitionsAssignment_4_3; }

		//BasicConstraintDefinition
		public RuleCall getBasicConstraintDefinitionsBasicConstraintDefinitionParserRuleCall_4_3_0() { return cBasicConstraintDefinitionsBasicConstraintDefinitionParserRuleCall_4_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class ParameterDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		/////////////////////////////////////////////
		//ParameterDeclaration:
		//	{ParameterDeclaration} name=ID ":" type=Type;
		@Override public ParserRule getRule() { return rule; }

		//{ParameterDeclaration} name=ID ":" type=Type
		public Group getGroup() { return cGroup; }

		//{ParameterDeclaration}
		public Action getParameterDeclarationAction_0() { return cParameterDeclarationAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }
	}

	public class FieldDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FieldDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFieldDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//FieldDeclaration:
		//	{FieldDeclaration} name=ID ":" type=Type;
		@Override public ParserRule getRule() { return rule; }

		//{FieldDeclaration} name=ID ":" type=Type
		public Group getGroup() { return cGroup; }

		//{FieldDeclaration}
		public Action getFieldDeclarationAction_0() { return cFieldDeclarationAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }
	}

	public class LetDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLetDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpressionExpressionParserRuleCall_5_0 = (RuleCall)cExpressionAssignment_5.eContents().get(0);
		
		//LetDeclaration:
		//	{LetDeclaration} name=ID ":" type=Type ":=" expression=Expression;
		@Override public ParserRule getRule() { return rule; }

		//{LetDeclaration} name=ID ":" type=Type ":=" expression=Expression
		public Group getGroup() { return cGroup; }

		//{LetDeclaration}
		public Action getLetDeclarationAction_0() { return cLetDeclarationAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_4() { return cColonEqualsSignKeyword_4; }

		//expression=Expression
		public Assignment getExpressionAssignment_5() { return cExpressionAssignment_5; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_5_0() { return cExpressionExpressionParserRuleCall_5_0; }
	}

	public class ConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cColonEqualsSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cExpressionAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_4_1_0 = (RuleCall)cExpressionAssignment_4_1.eContents().get(0);
		
		//ConstantDeclaration:
		//	"const" name=ID ":" type=Type (":=" expression=Expression)?;
		@Override public ParserRule getRule() { return rule; }

		//"const" name=ID ":" type=Type (":=" expression=Expression)?
		public Group getGroup() { return cGroup; }

		//"const"
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }

		//(":=" expression=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//":="
		public Keyword getColonEqualsSignKeyword_4_0() { return cColonEqualsSignKeyword_4_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_4_1() { return cExpressionAssignment_4_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_4_1_0() { return cExpressionExpressionParserRuleCall_4_1_0; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParameterDeclarationsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_0_0 = (RuleCall)cParameterDeclarationsAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParameterDeclarationsAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_1_1_0 = (RuleCall)cParameterDeclarationsAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeTypeParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cColonEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cExpressionAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_5_1_0 = (RuleCall)cExpressionAssignment_5_1.eContents().get(0);
		
		//FunctionDeclaration:
		//	"function" name=ID ("(" (parameterDeclarations+=ParameterDeclaration (","
		//	parameterDeclarations+=ParameterDeclaration)*)? ")")? ":" type=Type (":=" expression=Expression)?;
		@Override public ParserRule getRule() { return rule; }

		//"function" name=ID ("(" (parameterDeclarations+=ParameterDeclaration (","
		//parameterDeclarations+=ParameterDeclaration)*)? ")")? ":" type=Type (":=" expression=Expression)?
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//("(" (parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)? ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//(parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_2_1_0() { return cParameterDeclarationsAssignment_2_1_0; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_2_1_0_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_0_0; }

		//("," parameterDeclarations+=ParameterDeclaration)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }

		//","
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_2_1_1_1() { return cParameterDeclarationsAssignment_2_1_1_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_2_1_1_1_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_2_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//type=Type
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_4_0() { return cTypeTypeParserRuleCall_4_0; }

		//(":=" expression=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//":="
		public Keyword getColonEqualsSignKeyword_5_0() { return cColonEqualsSignKeyword_5_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_5_1() { return cExpressionAssignment_5_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_5_1_0() { return cExpressionExpressionParserRuleCall_5_1_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//////////////////////////////////////////
		//// Type language
		//////////////////////////////////////////
		//Type:
		//	TypeReference | TypeDefinition;
		@Override public ParserRule getRule() { return rule; }

		//TypeReference | TypeDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeReference
		public RuleCall getTypeReferenceParserRuleCall_0() { return cTypeReferenceParserRuleCall_0; }

		//TypeDefinition
		public RuleCall getTypeDefinitionParserRuleCall_1() { return cTypeDefinitionParserRuleCall_1; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//TypeDeclaration:
		//	"type" name=ID ":" type=Type;
		@Override public ParserRule getRule() { return rule; }

		//"type" name=ID ":" type=Type
		public Group getGroup() { return cGroup; }

		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }
	}

	public class TypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeReference");
		private final Assignment cReferenceAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cReferenceTypeDeclarationCrossReference_0 = (CrossReference)cReferenceAssignment.eContents().get(0);
		private final RuleCall cReferenceTypeDeclarationIDTerminalRuleCall_0_1 = (RuleCall)cReferenceTypeDeclarationCrossReference_0.eContents().get(1);
		
		//TypeReference:
		//	reference=[TypeDeclaration];
		@Override public ParserRule getRule() { return rule; }

		//reference=[TypeDeclaration]
		public Assignment getReferenceAssignment() { return cReferenceAssignment; }

		//[TypeDeclaration]
		public CrossReference getReferenceTypeDeclarationCrossReference_0() { return cReferenceTypeDeclarationCrossReference_0; }

		//ID
		public RuleCall getReferenceTypeDeclarationIDTerminalRuleCall_0_1() { return cReferenceTypeDeclarationIDTerminalRuleCall_0_1; }
	}

	public class TypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNaturalTypeDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntegerTypeDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanTypeDefinitionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRealTypeDefinitionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cArrayTypeDefinitionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cEnumerationTypeDefinitionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cRecordTypeDefinitionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cTupleTypeDefinitionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cSubrangeTypeDefinitionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cSubTypeDefinitionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cFunctionTypeDefinitionParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		//TypeDefinition:
		//	NaturalTypeDefinition | IntegerTypeDefinition | BooleanTypeDefinition | RealTypeDefinition | ArrayTypeDefinition |
		//	EnumerationTypeDefinition | RecordTypeDefinition | TupleTypeDefinition | SubrangeTypeDefinition | SubTypeDefinition |
		//	FunctionTypeDefinition;
		@Override public ParserRule getRule() { return rule; }

		//NaturalTypeDefinition | IntegerTypeDefinition | BooleanTypeDefinition | RealTypeDefinition | ArrayTypeDefinition |
		//EnumerationTypeDefinition | RecordTypeDefinition | TupleTypeDefinition | SubrangeTypeDefinition | SubTypeDefinition |
		//FunctionTypeDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//NaturalTypeDefinition
		public RuleCall getNaturalTypeDefinitionParserRuleCall_0() { return cNaturalTypeDefinitionParserRuleCall_0; }

		//IntegerTypeDefinition
		public RuleCall getIntegerTypeDefinitionParserRuleCall_1() { return cIntegerTypeDefinitionParserRuleCall_1; }

		//BooleanTypeDefinition
		public RuleCall getBooleanTypeDefinitionParserRuleCall_2() { return cBooleanTypeDefinitionParserRuleCall_2; }

		//RealTypeDefinition
		public RuleCall getRealTypeDefinitionParserRuleCall_3() { return cRealTypeDefinitionParserRuleCall_3; }

		//ArrayTypeDefinition
		public RuleCall getArrayTypeDefinitionParserRuleCall_4() { return cArrayTypeDefinitionParserRuleCall_4; }

		//EnumerationTypeDefinition
		public RuleCall getEnumerationTypeDefinitionParserRuleCall_5() { return cEnumerationTypeDefinitionParserRuleCall_5; }

		//RecordTypeDefinition
		public RuleCall getRecordTypeDefinitionParserRuleCall_6() { return cRecordTypeDefinitionParserRuleCall_6; }

		//TupleTypeDefinition
		public RuleCall getTupleTypeDefinitionParserRuleCall_7() { return cTupleTypeDefinitionParserRuleCall_7; }

		//SubrangeTypeDefinition
		public RuleCall getSubrangeTypeDefinitionParserRuleCall_8() { return cSubrangeTypeDefinitionParserRuleCall_8; }

		//SubTypeDefinition
		public RuleCall getSubTypeDefinitionParserRuleCall_9() { return cSubTypeDefinitionParserRuleCall_9; }

		//FunctionTypeDefinition
		public RuleCall getFunctionTypeDefinitionParserRuleCall_10() { return cFunctionTypeDefinitionParserRuleCall_10; }
	}

	public class NaturalTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NaturalTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNaturalTypeDefinitionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNaturalKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NaturalTypeDefinition returns BasicTypeDefinition:
		//	{NaturalTypeDefinition} "natural";
		@Override public ParserRule getRule() { return rule; }

		//{NaturalTypeDefinition} "natural"
		public Group getGroup() { return cGroup; }

		//{NaturalTypeDefinition}
		public Action getNaturalTypeDefinitionAction_0() { return cNaturalTypeDefinitionAction_0; }

		//"natural"
		public Keyword getNaturalKeyword_1() { return cNaturalKeyword_1; }
	}

	public class IntegerTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntegerTypeDefinitionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIntegerKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//IntegerTypeDefinition returns BasicTypeDefinition:
		//	{IntegerTypeDefinition} "integer";
		@Override public ParserRule getRule() { return rule; }

		//{IntegerTypeDefinition} "integer"
		public Group getGroup() { return cGroup; }

		//{IntegerTypeDefinition}
		public Action getIntegerTypeDefinitionAction_0() { return cIntegerTypeDefinitionAction_0; }

		//"integer"
		public Keyword getIntegerKeyword_1() { return cIntegerKeyword_1; }
	}

	public class BooleanTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBooleanTypeDefinitionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBooleanKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//BooleanTypeDefinition returns BasicTypeDefinition:
		//	{BooleanTypeDefinition} "boolean";
		@Override public ParserRule getRule() { return rule; }

		//{BooleanTypeDefinition} "boolean"
		public Group getGroup() { return cGroup; }

		//{BooleanTypeDefinition}
		public Action getBooleanTypeDefinitionAction_0() { return cBooleanTypeDefinitionAction_0; }

		//"boolean"
		public Keyword getBooleanKeyword_1() { return cBooleanKeyword_1; }
	}

	public class RealTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RealTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRealTypeDefinitionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRealKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//RealTypeDefinition:
		//	{RealTypeDefinition} "real";
		@Override public ParserRule getRule() { return rule; }

		//{RealTypeDefinition} "real"
		public Group getGroup() { return cGroup; }

		//{RealTypeDefinition}
		public Action getRealTypeDefinitionAction_0() { return cRealTypeDefinitionAction_0; }

		//"real"
		public Keyword getRealKeyword_1() { return cRealKeyword_1; }
	}

	public class ArrayTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexTypesTypeParserRuleCall_1_0 = (RuleCall)cIndexTypesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIndexTypesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIndexTypesTypeParserRuleCall_2_1_0 = (RuleCall)cIndexTypesAssignment_2_1.eContents().get(0);
		private final Keyword cOfKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cElementTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElementTypeTypeParserRuleCall_4_0 = (RuleCall)cElementTypeAssignment_4.eContents().get(0);
		
		//ArrayTypeDefinition:
		//	"array" indexTypes+=Type ("," indexTypes+=Type)* "of" elementType=Type;
		@Override public ParserRule getRule() { return rule; }

		//"array" indexTypes+=Type ("," indexTypes+=Type)* "of" elementType=Type
		public Group getGroup() { return cGroup; }

		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }

		//indexTypes+=Type
		public Assignment getIndexTypesAssignment_1() { return cIndexTypesAssignment_1; }

		//Type
		public RuleCall getIndexTypesTypeParserRuleCall_1_0() { return cIndexTypesTypeParserRuleCall_1_0; }

		//("," indexTypes+=Type)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//indexTypes+=Type
		public Assignment getIndexTypesAssignment_2_1() { return cIndexTypesAssignment_2_1; }

		//Type
		public RuleCall getIndexTypesTypeParserRuleCall_2_1_0() { return cIndexTypesTypeParserRuleCall_2_1_0; }

		//"of"
		public Keyword getOfKeyword_3() { return cOfKeyword_3; }

		//elementType=Type
		public Assignment getElementTypeAssignment_4() { return cElementTypeAssignment_4; }

		//Type
		public RuleCall getElementTypeTypeParserRuleCall_4_0() { return cElementTypeTypeParserRuleCall_4_0; }
	}

	public class EnumerationTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLiteralsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLiteralsEnumerationLiteralDefinitionParserRuleCall_2_0 = (RuleCall)cLiteralsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cLiteralsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cLiteralsEnumerationLiteralDefinitionParserRuleCall_3_1_0 = (RuleCall)cLiteralsAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//EnumerationTypeDefinition:
		//	"enum" "{" literals+=EnumerationLiteralDefinition ("," literals+=EnumerationLiteralDefinition)* "}";
		@Override public ParserRule getRule() { return rule; }

		//"enum" "{" literals+=EnumerationLiteralDefinition ("," literals+=EnumerationLiteralDefinition)* "}"
		public Group getGroup() { return cGroup; }

		//"enum"
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//literals+=EnumerationLiteralDefinition
		public Assignment getLiteralsAssignment_2() { return cLiteralsAssignment_2; }

		//EnumerationLiteralDefinition
		public RuleCall getLiteralsEnumerationLiteralDefinitionParserRuleCall_2_0() { return cLiteralsEnumerationLiteralDefinitionParserRuleCall_2_0; }

		//("," literals+=EnumerationLiteralDefinition)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//literals+=EnumerationLiteralDefinition
		public Assignment getLiteralsAssignment_3_1() { return cLiteralsAssignment_3_1; }

		//EnumerationLiteralDefinition
		public RuleCall getLiteralsEnumerationLiteralDefinitionParserRuleCall_3_1_0() { return cLiteralsEnumerationLiteralDefinitionParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class EnumerationLiteralDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationLiteralDefinition");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//EnumerationLiteralDefinition:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class RecordTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RecordTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRecordKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFieldDeclarationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFieldDeclarationsFieldDeclarationParserRuleCall_2_0 = (RuleCall)cFieldDeclarationsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFieldDeclarationsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFieldDeclarationsFieldDeclarationParserRuleCall_3_1_0 = (RuleCall)cFieldDeclarationsAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//RecordTypeDefinition:
		//	"record" "{" fieldDeclarations+=FieldDeclaration ("," fieldDeclarations+=FieldDeclaration)* "}";
		@Override public ParserRule getRule() { return rule; }

		//"record" "{" fieldDeclarations+=FieldDeclaration ("," fieldDeclarations+=FieldDeclaration)* "}"
		public Group getGroup() { return cGroup; }

		//"record"
		public Keyword getRecordKeyword_0() { return cRecordKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//fieldDeclarations+=FieldDeclaration
		public Assignment getFieldDeclarationsAssignment_2() { return cFieldDeclarationsAssignment_2; }

		//FieldDeclaration
		public RuleCall getFieldDeclarationsFieldDeclarationParserRuleCall_2_0() { return cFieldDeclarationsFieldDeclarationParserRuleCall_2_0; }

		//("," fieldDeclarations+=FieldDeclaration)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//fieldDeclarations+=FieldDeclaration
		public Assignment getFieldDeclarationsAssignment_3_1() { return cFieldDeclarationsAssignment_3_1; }

		//FieldDeclaration
		public RuleCall getFieldDeclarationsFieldDeclarationParserRuleCall_3_1_0() { return cFieldDeclarationsFieldDeclarationParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class TupleTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTupleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesTypeParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cTypesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cTypesTypeParserRuleCall_3_1_0 = (RuleCall)cTypesAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TupleTypeDefinition:
		//	"tuple" "{" types+=Type ("," types+=Type)* "}";
		@Override public ParserRule getRule() { return rule; }

		//"tuple" "{" types+=Type ("," types+=Type)* "}"
		public Group getGroup() { return cGroup; }

		//"tuple"
		public Keyword getTupleKeyword_0() { return cTupleKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//types+=Type
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_2_0() { return cTypesTypeParserRuleCall_2_0; }

		//("," types+=Type)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//types+=Type
		public Assignment getTypesAssignment_3_1() { return cTypesAssignment_3_1; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_3_1_0() { return cTypesTypeParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class SubrangeTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubrangeTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSubrangeTypeDefinitionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cInfKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Assignment cLowerBoundAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cLowerBoundExpressionParserRuleCall_2_1_0 = (RuleCall)cLowerBoundAssignment_2_1.eContents().get(0);
		private final Keyword cToKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Keyword cInfKeyword_4_0 = (Keyword)cAlternatives_4.eContents().get(0);
		private final Assignment cUpperBoundAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cUpperBoundExpressionParserRuleCall_4_1_0 = (RuleCall)cUpperBoundAssignment_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//SubrangeTypeDefinition:
		//	{SubrangeTypeDefinition} "[" ("-" "inf" | lowerBound=Expression) "to" ("inf" | upperBound=Expression) "]";
		@Override public ParserRule getRule() { return rule; }

		//{SubrangeTypeDefinition} "[" ("-" "inf" | lowerBound=Expression) "to" ("inf" | upperBound=Expression) "]"
		public Group getGroup() { return cGroup; }

		//{SubrangeTypeDefinition}
		public Action getSubrangeTypeDefinitionAction_0() { return cSubrangeTypeDefinitionAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//"-" "inf" | lowerBound=Expression
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"-" "inf"
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_2_0_0() { return cHyphenMinusKeyword_2_0_0; }

		//"inf"
		public Keyword getInfKeyword_2_0_1() { return cInfKeyword_2_0_1; }

		//lowerBound=Expression
		public Assignment getLowerBoundAssignment_2_1() { return cLowerBoundAssignment_2_1; }

		//Expression
		public RuleCall getLowerBoundExpressionParserRuleCall_2_1_0() { return cLowerBoundExpressionParserRuleCall_2_1_0; }

		//"to"
		public Keyword getToKeyword_3() { return cToKeyword_3; }

		//"inf" | upperBound=Expression
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//"inf"
		public Keyword getInfKeyword_4_0() { return cInfKeyword_4_0; }

		//upperBound=Expression
		public Assignment getUpperBoundAssignment_4_1() { return cUpperBoundAssignment_4_1; }

		//Expression
		public RuleCall getUpperBoundExpressionParserRuleCall_4_1_0() { return cUpperBoundExpressionParserRuleCall_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class SubTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParameterDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParameterDeclarationParameterDeclarationParserRuleCall_1_0 = (RuleCall)cParameterDeclarationAssignment_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SubTypeDefinition:
		//	"{" parameterDeclaration=ParameterDeclaration "|" expression=Expression "}";
		@Override public ParserRule getRule() { return rule; }

		//"{" parameterDeclaration=ParameterDeclaration "|" expression=Expression "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//parameterDeclaration=ParameterDeclaration
		public Assignment getParameterDeclarationAssignment_1() { return cParameterDeclarationAssignment_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationParameterDeclarationParserRuleCall_1_0() { return cParameterDeclarationParameterDeclarationParserRuleCall_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class FunctionTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterTypesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterTypesTypeParserRuleCall_2_0_0 = (RuleCall)cParameterTypesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterTypesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterTypesTypeParserRuleCall_2_1_1_0 = (RuleCall)cParameterTypesAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cReturnTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cReturnTypeTypeParserRuleCall_5_0 = (RuleCall)cReturnTypeAssignment_5.eContents().get(0);
		
		//FunctionTypeDefinition:
		//	"function" "(" (parameterTypes+=Type ("," parameterTypes+=Type)*)? ")" ":" returnType=Type;
		@Override public ParserRule getRule() { return rule; }

		//"function" "(" (parameterTypes+=Type ("," parameterTypes+=Type)*)? ")" ":" returnType=Type
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameterTypes+=Type ("," parameterTypes+=Type)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameterTypes+=Type
		public Assignment getParameterTypesAssignment_2_0() { return cParameterTypesAssignment_2_0; }

		//Type
		public RuleCall getParameterTypesTypeParserRuleCall_2_0_0() { return cParameterTypesTypeParserRuleCall_2_0_0; }

		//("," parameterTypes+=Type)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameterTypes+=Type
		public Assignment getParameterTypesAssignment_2_1_1() { return cParameterTypesAssignment_2_1_1; }

		//Type
		public RuleCall getParameterTypesTypeParserRuleCall_2_1_1_0() { return cParameterTypesTypeParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//returnType=Type
		public Assignment getReturnTypeAssignment_5() { return cReturnTypeAssignment_5; }

		//Type
		public RuleCall getReturnTypeTypeParserRuleCall_5_0() { return cReturnTypeTypeParserRuleCall_5_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cIfThenElseExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//////////////////////////////////////////
		//// Expression language
		//////////////////////////////////////////
		//Expression:
		//	IfThenElseExpression;
		@Override public ParserRule getRule() { return rule; }

		//IfThenElseExpression
		public RuleCall getIfThenElseExpressionParserRuleCall() { return cIfThenElseExpressionParserRuleCall; }
	}

	public class IfThenElseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfThenElseExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIfThenElseExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cIfKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cConditionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_0_2_0 = (RuleCall)cConditionAssignment_0_2.eContents().get(0);
		private final Keyword cThenKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cThenAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cThenExpressionParserRuleCall_0_4_0 = (RuleCall)cThenAssignment_0_4.eContents().get(0);
		private final Group cGroup_0_5 = (Group)cGroup_0.eContents().get(5);
		private final Keyword cElseKeyword_0_5_0 = (Keyword)cGroup_0_5.eContents().get(0);
		private final Assignment cElseAssignment_0_5_1 = (Assignment)cGroup_0_5.eContents().get(1);
		private final RuleCall cElseExpressionParserRuleCall_0_5_1_0 = (RuleCall)cElseAssignment_0_5_1.eContents().get(0);
		private final RuleCall cEqualExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////ternary, right-associative
		//IfThenElseExpression returns Expression:
		//	{IfThenElseExpression} "if" condition=Expression "then" then=Expression ("else" else=Expression) | EqualExpression;
		@Override public ParserRule getRule() { return rule; }

		//{IfThenElseExpression} "if" condition=Expression "then" then=Expression ("else" else=Expression) | EqualExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{IfThenElseExpression} "if" condition=Expression "then" then=Expression ("else" else=Expression)
		public Group getGroup_0() { return cGroup_0; }

		//{IfThenElseExpression}
		public Action getIfThenElseExpressionAction_0_0() { return cIfThenElseExpressionAction_0_0; }

		//"if"
		public Keyword getIfKeyword_0_1() { return cIfKeyword_0_1; }

		//condition=Expression
		public Assignment getConditionAssignment_0_2() { return cConditionAssignment_0_2; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_0_2_0() { return cConditionExpressionParserRuleCall_0_2_0; }

		//"then"
		public Keyword getThenKeyword_0_3() { return cThenKeyword_0_3; }

		//then=Expression
		public Assignment getThenAssignment_0_4() { return cThenAssignment_0_4; }

		//Expression
		public RuleCall getThenExpressionParserRuleCall_0_4_0() { return cThenExpressionParserRuleCall_0_4_0; }

		//=> "else" else=Expression
		public Group getGroup_0_5() { return cGroup_0_5; }

		//=> "else"
		public Keyword getElseKeyword_0_5_0() { return cElseKeyword_0_5_0; }

		//else=Expression
		public Assignment getElseAssignment_0_5_1() { return cElseAssignment_0_5_1; }

		//Expression
		public RuleCall getElseExpressionParserRuleCall_0_5_1_0() { return cElseExpressionParserRuleCall_0_5_1_0; }

		//EqualExpression
		public RuleCall getEqualExpressionParserRuleCall_1() { return cEqualExpressionParserRuleCall_1; }
	}

	public class EqualExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImplyExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandEqualExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		////binary, right-associative
		//EqualExpression returns Expression:
		//	ImplyExpression ({EqualExpression.leftOperand=current} "equal" rightOperand=EqualExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//ImplyExpression ({EqualExpression.leftOperand=current} "equal" rightOperand=EqualExpression)?
		public Group getGroup() { return cGroup; }

		//ImplyExpression
		public RuleCall getImplyExpressionParserRuleCall_0() { return cImplyExpressionParserRuleCall_0; }

		//({EqualExpression.leftOperand=current} "equal" rightOperand=EqualExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{EqualExpression.leftOperand=current}
		public Action getEqualExpressionLeftOperandAction_1_0() { return cEqualExpressionLeftOperandAction_1_0; }

		//"equal"
		public Keyword getEqualKeyword_1_1() { return cEqualKeyword_1_1; }

		//rightOperand=EqualExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//EqualExpression
		public RuleCall getRightOperandEqualExpressionParserRuleCall_1_2_0() { return cRightOperandEqualExpressionParserRuleCall_1_2_0; }
	}

	public class ImplyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImplyExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplyExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImplyKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandImplyExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		////binary, right-associative
		//ImplyExpression returns Expression:
		//	OrExpression ({ImplyExpression.leftOperand=current} "imply" rightOperand=ImplyExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//OrExpression ({ImplyExpression.leftOperand=current} "imply" rightOperand=ImplyExpression)?
		public Group getGroup() { return cGroup; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//({ImplyExpression.leftOperand=current} "imply" rightOperand=ImplyExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{ImplyExpression.leftOperand=current}
		public Action getImplyExpressionLeftOperandAction_1_0() { return cImplyExpressionLeftOperandAction_1_0; }

		//"imply"
		public Keyword getImplyKeyword_1_1() { return cImplyKeyword_1_1; }

		//rightOperand=ImplyExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//ImplyExpression
		public RuleCall getRightOperandImplyExpressionParserRuleCall_1_2_0() { return cRightOperandImplyExpressionParserRuleCall_1_2_0; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionOperandsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cOrKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cOperandsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperandsAndExpressionParserRuleCall_1_1_1_0 = (RuleCall)cOperandsAssignment_1_1_1.eContents().get(0);
		
		////multiary
		//OrExpression returns Expression:
		//	AndExpression ({OrExpression.operands+=current} ("or" operands+=AndExpression)+)?;
		@Override public ParserRule getRule() { return rule; }

		//AndExpression ({OrExpression.operands+=current} ("or" operands+=AndExpression)+)?
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({OrExpression.operands+=current} ("or" operands+=AndExpression)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{OrExpression.operands+=current}
		public Action getOrExpressionOperandsAction_1_0() { return cOrExpressionOperandsAction_1_0; }

		//("or" operands+=AndExpression)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"or"
		public Keyword getOrKeyword_1_1_0() { return cOrKeyword_1_1_0; }

		//operands+=AndExpression
		public Assignment getOperandsAssignment_1_1_1() { return cOperandsAssignment_1_1_1; }

		//AndExpression
		public RuleCall getOperandsAndExpressionParserRuleCall_1_1_1_0() { return cOperandsAndExpressionParserRuleCall_1_1_1_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cReleaseExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionOperandsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cAndKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cOperandsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperandsReleaseExpressionParserRuleCall_1_1_1_0 = (RuleCall)cOperandsAssignment_1_1_1.eContents().get(0);
		
		////multiary
		//AndExpression returns Expression:
		//	ReleaseExpression ({AndExpression.operands+=current} ("and" operands+=ReleaseExpression)+)?;
		@Override public ParserRule getRule() { return rule; }

		//ReleaseExpression ({AndExpression.operands+=current} ("and" operands+=ReleaseExpression)+)?
		public Group getGroup() { return cGroup; }

		//ReleaseExpression
		public RuleCall getReleaseExpressionParserRuleCall_0() { return cReleaseExpressionParserRuleCall_0; }

		//({AndExpression.operands+=current} ("and" operands+=ReleaseExpression)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{AndExpression.operands+=current}
		public Action getAndExpressionOperandsAction_1_0() { return cAndExpressionOperandsAction_1_0; }

		//("and" operands+=ReleaseExpression)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"and"
		public Keyword getAndKeyword_1_1_0() { return cAndKeyword_1_1_0; }

		//operands+=ReleaseExpression
		public Assignment getOperandsAssignment_1_1_1() { return cOperandsAssignment_1_1_1; }

		//ReleaseExpression
		public RuleCall getOperandsReleaseExpressionParserRuleCall_1_1_1_0() { return cOperandsReleaseExpressionParserRuleCall_1_1_1_0; }
	}

	public class ReleaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReleaseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUntilExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cReleaseExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cRKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandUntilExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		////binary, left-associative
		//ReleaseExpression returns Expression:
		//	UntilExpression ({ReleaseExpression.leftOperand=current} "R" rightOperand=UntilExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//UntilExpression ({ReleaseExpression.leftOperand=current} "R" rightOperand=UntilExpression)*
		public Group getGroup() { return cGroup; }

		//UntilExpression
		public RuleCall getUntilExpressionParserRuleCall_0() { return cUntilExpressionParserRuleCall_0; }

		//({ReleaseExpression.leftOperand=current} "R" rightOperand=UntilExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ReleaseExpression.leftOperand=current}
		public Action getReleaseExpressionLeftOperandAction_1_0() { return cReleaseExpressionLeftOperandAction_1_0; }

		//"R"
		public Keyword getRKeyword_1_1() { return cRKeyword_1_1; }

		//rightOperand=UntilExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//UntilExpression
		public RuleCall getRightOperandUntilExpressionParserRuleCall_1_2_0() { return cRightOperandUntilExpressionParserRuleCall_1_2_0; }
	}

	public class UntilExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UntilExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryLogicExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUntilExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cUKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandUnaryLogicExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		////binary, left-associative
		//UntilExpression returns Expression:
		//	UnaryLogicExpression ({UntilExpression.leftOperand=current} "U" rightOperand=UnaryLogicExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//UnaryLogicExpression ({UntilExpression.leftOperand=current} "U" rightOperand=UnaryLogicExpression)*
		public Group getGroup() { return cGroup; }

		//UnaryLogicExpression
		public RuleCall getUnaryLogicExpressionParserRuleCall_0() { return cUnaryLogicExpressionParserRuleCall_0; }

		//({UntilExpression.leftOperand=current} "U" rightOperand=UnaryLogicExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{UntilExpression.leftOperand=current}
		public Action getUntilExpressionLeftOperandAction_1_0() { return cUntilExpressionLeftOperandAction_1_0; }

		//"U"
		public Keyword getUKeyword_1_1() { return cUKeyword_1_1; }

		//rightOperand=UnaryLogicExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//UnaryLogicExpression
		public RuleCall getRightOperandUnaryLogicExpressionParserRuleCall_1_2_0() { return cRightOperandUnaryLogicExpressionParserRuleCall_1_2_0; }
	}

	public class UnaryLogicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryLogicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNotExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForallExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExistsExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFunctionLiteralExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cGloballyExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cFinallyExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNextExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cTemporalForallExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cTemporalExistsExpressionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cLetExpressionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cInExpressionParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		////prefix unary, right-associative
		//UnaryLogicExpression returns Expression:
		//	NotExpression | ForallExpression | ExistsExpression | FunctionLiteralExpression | GloballyExpression |
		//	FinallyExpression | NextExpression | TemporalForallExpression | TemporalExistsExpression | LetExpression |
		//	InExpression;
		@Override public ParserRule getRule() { return rule; }

		//NotExpression | ForallExpression | ExistsExpression | FunctionLiteralExpression | GloballyExpression | FinallyExpression
		//| NextExpression | TemporalForallExpression | TemporalExistsExpression | LetExpression | InExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//NotExpression
		public RuleCall getNotExpressionParserRuleCall_0() { return cNotExpressionParserRuleCall_0; }

		//ForallExpression
		public RuleCall getForallExpressionParserRuleCall_1() { return cForallExpressionParserRuleCall_1; }

		//ExistsExpression
		public RuleCall getExistsExpressionParserRuleCall_2() { return cExistsExpressionParserRuleCall_2; }

		//FunctionLiteralExpression
		public RuleCall getFunctionLiteralExpressionParserRuleCall_3() { return cFunctionLiteralExpressionParserRuleCall_3; }

		//GloballyExpression
		public RuleCall getGloballyExpressionParserRuleCall_4() { return cGloballyExpressionParserRuleCall_4; }

		//FinallyExpression
		public RuleCall getFinallyExpressionParserRuleCall_5() { return cFinallyExpressionParserRuleCall_5; }

		//NextExpression
		public RuleCall getNextExpressionParserRuleCall_6() { return cNextExpressionParserRuleCall_6; }

		//TemporalForallExpression
		public RuleCall getTemporalForallExpressionParserRuleCall_7() { return cTemporalForallExpressionParserRuleCall_7; }

		//TemporalExistsExpression
		public RuleCall getTemporalExistsExpressionParserRuleCall_8() { return cTemporalExistsExpressionParserRuleCall_8; }

		//LetExpression
		public RuleCall getLetExpressionParserRuleCall_9() { return cLetExpressionParserRuleCall_9; }

		//InExpression
		public RuleCall getInExpressionParserRuleCall_10() { return cInExpressionParserRuleCall_10; }
	}

	public class NotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//NotExpression returns Expression:
		//	{NotExpression} => "not" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{NotExpression} => "not" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{NotExpression}
		public Action getNotExpressionAction_0() { return cNotExpressionAction_0; }

		//=> "not"
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_2_0() { return cOperandUnaryLogicExpressionParserRuleCall_2_0; }
	}

	public class ForallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForallExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForallKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParameterDeclarationsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0 = (RuleCall)cParameterDeclarationsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParameterDeclarationsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0 = (RuleCall)cParameterDeclarationsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOperandAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_6_0 = (RuleCall)cOperandAssignment_6.eContents().get(0);
		
		//ForallExpression returns Expression:
		//	{ForallExpression} => "forall" "(" (parameterDeclarations+=ParameterDeclaration (","
		//	parameterDeclarations+=ParameterDeclaration)*)? ")" ":" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{ForallExpression} => "forall" "(" (parameterDeclarations+=ParameterDeclaration (","
		//parameterDeclarations+=ParameterDeclaration)*)? ")" ":" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{ForallExpression}
		public Action getForallExpressionAction_0() { return cForallExpressionAction_0; }

		//=> "forall"
		public Keyword getForallKeyword_1() { return cForallKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)?
		public Group getGroup_3() { return cGroup_3; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_3_0() { return cParameterDeclarationsAssignment_3_0; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0; }

		//("," parameterDeclarations+=ParameterDeclaration)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_3_1_1() { return cParameterDeclarationsAssignment_3_1_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_6() { return cOperandAssignment_6; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_6_0() { return cOperandUnaryLogicExpressionParserRuleCall_6_0; }
	}

	public class ExistsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExistsExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExistsExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParameterDeclarationsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0 = (RuleCall)cParameterDeclarationsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParameterDeclarationsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0 = (RuleCall)cParameterDeclarationsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOperandAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_6_0 = (RuleCall)cOperandAssignment_6.eContents().get(0);
		
		//ExistsExpression returns Expression:
		//	{ExistsExpression} => "exists" "(" (parameterDeclarations+=ParameterDeclaration (","
		//	parameterDeclarations+=ParameterDeclaration)*)? ")" ":" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{ExistsExpression} => "exists" "(" (parameterDeclarations+=ParameterDeclaration (","
		//parameterDeclarations+=ParameterDeclaration)*)? ")" ":" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{ExistsExpression}
		public Action getExistsExpressionAction_0() { return cExistsExpressionAction_0; }

		//=> "exists"
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)?
		public Group getGroup_3() { return cGroup_3; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_3_0() { return cParameterDeclarationsAssignment_3_0; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0; }

		//("," parameterDeclarations+=ParameterDeclaration)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_3_1_1() { return cParameterDeclarationsAssignment_3_1_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_6() { return cOperandAssignment_6; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_6_0() { return cOperandUnaryLogicExpressionParserRuleCall_6_0; }
	}

	public class FunctionLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFunctionKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParameterDeclarationsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0 = (RuleCall)cParameterDeclarationsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParameterDeclarationsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0 = (RuleCall)cParameterDeclarationsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeTypeParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cOperandAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_8_0 = (RuleCall)cOperandAssignment_8.eContents().get(0);
		
		//FunctionLiteralExpression returns Expression:
		//	{FunctionLiteralExpression} => "function" "(" (parameterDeclarations+=ParameterDeclaration (","
		//	parameterDeclarations+=ParameterDeclaration)*)? ")" ":" returnType=Type ":=" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{FunctionLiteralExpression} => "function" "(" (parameterDeclarations+=ParameterDeclaration (","
		//parameterDeclarations+=ParameterDeclaration)*)? ")" ":" returnType=Type ":=" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{FunctionLiteralExpression}
		public Action getFunctionLiteralExpressionAction_0() { return cFunctionLiteralExpressionAction_0; }

		//=> "function"
		public Keyword getFunctionKeyword_1() { return cFunctionKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)?
		public Group getGroup_3() { return cGroup_3; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_3_0() { return cParameterDeclarationsAssignment_3_0; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_3_0_0; }

		//("," parameterDeclarations+=ParameterDeclaration)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_3_1_1() { return cParameterDeclarationsAssignment_3_1_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }

		//returnType=Type
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }

		//Type
		public RuleCall getReturnTypeTypeParserRuleCall_6_0() { return cReturnTypeTypeParserRuleCall_6_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_7() { return cColonEqualsSignKeyword_7; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_8() { return cOperandAssignment_8; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_8_0() { return cOperandUnaryLogicExpressionParserRuleCall_8_0; }
	}

	public class GloballyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GloballyExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGloballyExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cGKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//GloballyExpression returns Expression:
		//	{GloballyExpression} => "G" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{GloballyExpression} => "G" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{GloballyExpression}
		public Action getGloballyExpressionAction_0() { return cGloballyExpressionAction_0; }

		//=> "G"
		public Keyword getGKeyword_1() { return cGKeyword_1; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_2_0() { return cOperandUnaryLogicExpressionParserRuleCall_2_0; }
	}

	public class FinallyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FinallyExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFinallyExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//FinallyExpression returns Expression:
		//	{FinallyExpression} => "F" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{FinallyExpression} => "F" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{FinallyExpression}
		public Action getFinallyExpressionAction_0() { return cFinallyExpressionAction_0; }

		//=> "F"
		public Keyword getFKeyword_1() { return cFKeyword_1; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_2_0() { return cOperandUnaryLogicExpressionParserRuleCall_2_0; }
	}

	public class NextExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NextExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNextExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cXKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//NextExpression returns Expression:
		//	{NextExpression} => "X" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{NextExpression} => "X" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{NextExpression}
		public Action getNextExpressionAction_0() { return cNextExpressionAction_0; }

		//=> "X"
		public Keyword getXKeyword_1() { return cXKeyword_1; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_2_0() { return cOperandUnaryLogicExpressionParserRuleCall_2_0; }
	}

	public class TemporalForallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TemporalForallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTemporalForallExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//TemporalForallExpression returns Expression:
		//	{TemporalForallExpression} => "A" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{TemporalForallExpression} => "A" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{TemporalForallExpression}
		public Action getTemporalForallExpressionAction_0() { return cTemporalForallExpressionAction_0; }

		//=> "A"
		public Keyword getAKeyword_1() { return cAKeyword_1; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_2_0() { return cOperandUnaryLogicExpressionParserRuleCall_2_0; }
	}

	public class TemporalExistsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TemporalExistsExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTemporalExistsExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandUnaryLogicExpressionParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//TemporalExistsExpression returns Expression:
		//	{TemporalExistsExpression} => "E" operand=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{TemporalExistsExpression} => "E" operand=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{TemporalExistsExpression}
		public Action getTemporalExistsExpressionAction_0() { return cTemporalExistsExpressionAction_0; }

		//=> "E"
		public Keyword getEKeyword_1() { return cEKeyword_1; }

		//operand=UnaryLogicExpression
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }

		//UnaryLogicExpression
		public RuleCall getOperandUnaryLogicExpressionParserRuleCall_2_0() { return cOperandUnaryLogicExpressionParserRuleCall_2_0; }
	}

	public class LetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLetExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cLetDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLetDeclarationsLetDeclarationParserRuleCall_3_0 = (RuleCall)cLetDeclarationsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cLetDeclarationsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cLetDeclarationsLetDeclarationParserRuleCall_4_1_0 = (RuleCall)cLetDeclarationsAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cInKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cExpressionAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cExpressionUnaryLogicExpressionParserRuleCall_7_0 = (RuleCall)cExpressionAssignment_7.eContents().get(0);
		
		//LetExpression returns Expression:
		//	{LetExpression} "let" "(" letDeclarations+=LetDeclaration ("," letDeclarations+=LetDeclaration)* ")" "in"
		//	expression=UnaryLogicExpression;
		@Override public ParserRule getRule() { return rule; }

		//{LetExpression} "let" "(" letDeclarations+=LetDeclaration ("," letDeclarations+=LetDeclaration)* ")" "in"
		//expression=UnaryLogicExpression
		public Group getGroup() { return cGroup; }

		//{LetExpression}
		public Action getLetExpressionAction_0() { return cLetExpressionAction_0; }

		//"let"
		public Keyword getLetKeyword_1() { return cLetKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//letDeclarations+=LetDeclaration
		public Assignment getLetDeclarationsAssignment_3() { return cLetDeclarationsAssignment_3; }

		//LetDeclaration
		public RuleCall getLetDeclarationsLetDeclarationParserRuleCall_3_0() { return cLetDeclarationsLetDeclarationParserRuleCall_3_0; }

		//("," letDeclarations+=LetDeclaration)*
		public Group getGroup_4() { return cGroup_4; }

		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//letDeclarations+=LetDeclaration
		public Assignment getLetDeclarationsAssignment_4_1() { return cLetDeclarationsAssignment_4_1; }

		//LetDeclaration
		public RuleCall getLetDeclarationsLetDeclarationParserRuleCall_4_1_0() { return cLetDeclarationsLetDeclarationParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//"in"
		public Keyword getInKeyword_6() { return cInKeyword_6; }

		//expression=UnaryLogicExpression
		public Assignment getExpressionAssignment_7() { return cExpressionAssignment_7; }

		//UnaryLogicExpression
		public RuleCall getExpressionUnaryLogicExpressionParserRuleCall_7_0() { return cExpressionUnaryLogicExpressionParserRuleCall_7_0; }
	}

	public class InExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEquivalenceExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInExpressionOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cInKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_1_2_0 = (RuleCall)cTypeAssignment_1_2.eContents().get(0);
		
		////postfix unary, non-associative
		//InExpression returns Expression:
		//	EquivalenceExpression ({InExpression.operand=current} "in" type=Type)?;
		@Override public ParserRule getRule() { return rule; }

		//EquivalenceExpression ({InExpression.operand=current} "in" type=Type)?
		public Group getGroup() { return cGroup; }

		//EquivalenceExpression
		public RuleCall getEquivalenceExpressionParserRuleCall_0() { return cEquivalenceExpressionParserRuleCall_0; }

		//({InExpression.operand=current} "in" type=Type)?
		public Group getGroup_1() { return cGroup_1; }

		//{InExpression.operand=current}
		public Action getInExpressionOperandAction_1_0() { return cInExpressionOperandAction_1_0; }

		//"in"
		public Keyword getInKeyword_1_1() { return cInKeyword_1_1; }

		//type=Type
		public Assignment getTypeAssignment_1_2() { return cTypeAssignment_1_2; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_2_0() { return cTypeTypeParserRuleCall_1_2_0; }
	}

	public class EquivalenceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EquivalenceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisionExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cEqualityExpressionLeftOperandAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightOperandComparisionExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRightOperandAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cInequalityExpressionLeftOperandAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cSolidusEqualsSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightOperandComparisionExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRightOperandAssignment_1_1_2.eContents().get(0);
		
		////binary, non-associative
		//EquivalenceExpression returns Expression:
		//	ComparisionExpression ({EqualityExpression.leftOperand=current} "=" rightOperand=ComparisionExpression |
		//	{InequalityExpression.leftOperand=current} "/=" rightOperand=ComparisionExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//ComparisionExpression ({EqualityExpression.leftOperand=current} "=" rightOperand=ComparisionExpression |
		//{InequalityExpression.leftOperand=current} "/=" rightOperand=ComparisionExpression)?
		public Group getGroup() { return cGroup; }

		//ComparisionExpression
		public RuleCall getComparisionExpressionParserRuleCall_0() { return cComparisionExpressionParserRuleCall_0; }

		//({EqualityExpression.leftOperand=current} "=" rightOperand=ComparisionExpression |
		//{InequalityExpression.leftOperand=current} "/=" rightOperand=ComparisionExpression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{EqualityExpression.leftOperand=current} "=" rightOperand=ComparisionExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{EqualityExpression.leftOperand=current}
		public Action getEqualityExpressionLeftOperandAction_1_0_0() { return cEqualityExpressionLeftOperandAction_1_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_0_1() { return cEqualsSignKeyword_1_0_1; }

		//rightOperand=ComparisionExpression
		public Assignment getRightOperandAssignment_1_0_2() { return cRightOperandAssignment_1_0_2; }

		//ComparisionExpression
		public RuleCall getRightOperandComparisionExpressionParserRuleCall_1_0_2_0() { return cRightOperandComparisionExpressionParserRuleCall_1_0_2_0; }

		//{InequalityExpression.leftOperand=current} "/=" rightOperand=ComparisionExpression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{InequalityExpression.leftOperand=current}
		public Action getInequalityExpressionLeftOperandAction_1_1_0() { return cInequalityExpressionLeftOperandAction_1_1_0; }

		//"/="
		public Keyword getSolidusEqualsSignKeyword_1_1_1() { return cSolidusEqualsSignKeyword_1_1_1; }

		//rightOperand=ComparisionExpression
		public Assignment getRightOperandAssignment_1_1_2() { return cRightOperandAssignment_1_1_2; }

		//ComparisionExpression
		public RuleCall getRightOperandComparisionExpressionParserRuleCall_1_1_2_0() { return cRightOperandComparisionExpressionParserRuleCall_1_1_2_0; }
	}

	public class ComparisionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cGreaterExpressionLeftOperandAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cGreaterEqualExpressionLeftOperandAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cLessExpressionLeftOperandAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Group cGroup_1_0_3 = (Group)cAlternatives_1_0.eContents().get(3);
		private final Action cLessEqualExpressionLeftOperandAction_1_0_3_0 = (Action)cGroup_1_0_3.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_3_1 = (Keyword)cGroup_1_0_3.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightOperandAdditiveExpressionParserRuleCall_1_1_0 = (RuleCall)cRightOperandAssignment_1_1.eContents().get(0);
		
		////binary, non-associative
		//ComparisionExpression returns Expression:
		//	AdditiveExpression (({GreaterExpression.leftOperand=current} ">" | {GreaterEqualExpression.leftOperand=current} ">=" |
		//	{LessExpression.leftOperand=current} "<" | {LessEqualExpression.leftOperand=current} "<=")
		//	rightOperand=AdditiveExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//AdditiveExpression (({GreaterExpression.leftOperand=current} ">" | {GreaterEqualExpression.leftOperand=current} ">=" |
		//{LessExpression.leftOperand=current} "<" | {LessEqualExpression.leftOperand=current} "<=")
		//rightOperand=AdditiveExpression)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//(({GreaterExpression.leftOperand=current} ">" | {GreaterEqualExpression.leftOperand=current} ">=" |
		//{LessExpression.leftOperand=current} "<" | {LessEqualExpression.leftOperand=current} "<=")
		//rightOperand=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{GreaterExpression.leftOperand=current} ">" | {GreaterEqualExpression.leftOperand=current} ">=" |
		//{LessExpression.leftOperand=current} "<" | {LessEqualExpression.leftOperand=current} "<="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{GreaterExpression.leftOperand=current} ">"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{GreaterExpression.leftOperand=current}
		public Action getGreaterExpressionLeftOperandAction_1_0_0_0() { return cGreaterExpressionLeftOperandAction_1_0_0_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_0_1() { return cGreaterThanSignKeyword_1_0_0_1; }

		//{GreaterEqualExpression.leftOperand=current} ">="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{GreaterEqualExpression.leftOperand=current}
		public Action getGreaterEqualExpressionLeftOperandAction_1_0_1_0() { return cGreaterEqualExpressionLeftOperandAction_1_0_1_0; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0_1_1() { return cGreaterThanSignEqualsSignKeyword_1_0_1_1; }

		//{LessExpression.leftOperand=current} "<"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{LessExpression.leftOperand=current}
		public Action getLessExpressionLeftOperandAction_1_0_2_0() { return cLessExpressionLeftOperandAction_1_0_2_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0_2_1() { return cLessThanSignKeyword_1_0_2_1; }

		//{LessEqualExpression.leftOperand=current} "<="
		public Group getGroup_1_0_3() { return cGroup_1_0_3; }

		//{LessEqualExpression.leftOperand=current}
		public Action getLessEqualExpressionLeftOperandAction_1_0_3_0() { return cLessEqualExpressionLeftOperandAction_1_0_3_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_3_1() { return cLessThanSignEqualsSignKeyword_1_0_3_1; }

		//rightOperand=AdditiveExpression
		public Assignment getRightOperandAssignment_1_1() { return cRightOperandAssignment_1_1; }

		//AdditiveExpression
		public RuleCall getRightOperandAdditiveExpressionParserRuleCall_1_1_0() { return cRightOperandAdditiveExpressionParserRuleCall_1_1_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cAddExpressionOperandsAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_0_1_0 = (Group)cGroup_1_0_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_1_0_0 = (Keyword)cGroup_1_0_1_0.eContents().get(0);
		private final Assignment cOperandsAssignment_1_0_1_0_1 = (Assignment)cGroup_1_0_1_0.eContents().get(1);
		private final RuleCall cOperandsMultiplicativeExpressionParserRuleCall_1_0_1_0_1_0 = (RuleCall)cOperandsAssignment_1_0_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cSubtractExpressionLeftOperandAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightOperandMultiplicativeExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRightOperandAssignment_1_1_2.eContents().get(0);
		
		////binary, left-associative
		//AdditiveExpression returns Expression:
		//	MultiplicativeExpression ({AddExpression.operands+=current} => ("+" operands+=MultiplicativeExpression)+ |
		//	{SubtractExpression.leftOperand=current} "-" rightOperand=MultiplicativeExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({AddExpression.operands+=current} => ("+" operands+=MultiplicativeExpression)+ |
		//{SubtractExpression.leftOperand=current} "-" rightOperand=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({AddExpression.operands+=current} => ("+" operands+=MultiplicativeExpression)+ |
		//{SubtractExpression.leftOperand=current} "-" rightOperand=MultiplicativeExpression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{AddExpression.operands+=current} => ("+" operands+=MultiplicativeExpression)+
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{AddExpression.operands+=current}
		public Action getAddExpressionOperandsAction_1_0_0() { return cAddExpressionOperandsAction_1_0_0; }

		//=> ("+" operands+=MultiplicativeExpression)+
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//"+" operands+=MultiplicativeExpression
		public Group getGroup_1_0_1_0() { return cGroup_1_0_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_1_0_0() { return cPlusSignKeyword_1_0_1_0_0; }

		//operands+=MultiplicativeExpression
		public Assignment getOperandsAssignment_1_0_1_0_1() { return cOperandsAssignment_1_0_1_0_1; }

		//MultiplicativeExpression
		public RuleCall getOperandsMultiplicativeExpressionParserRuleCall_1_0_1_0_1_0() { return cOperandsMultiplicativeExpressionParserRuleCall_1_0_1_0_1_0; }

		//{SubtractExpression.leftOperand=current} "-" rightOperand=MultiplicativeExpression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{SubtractExpression.leftOperand=current}
		public Action getSubtractExpressionLeftOperandAction_1_1_0() { return cSubtractExpressionLeftOperandAction_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1() { return cHyphenMinusKeyword_1_1_1; }

		//rightOperand=MultiplicativeExpression
		public Assignment getRightOperandAssignment_1_1_2() { return cRightOperandAssignment_1_1_2; }

		//MultiplicativeExpression
		public RuleCall getRightOperandMultiplicativeExpressionParserRuleCall_1_1_2_0() { return cRightOperandMultiplicativeExpressionParserRuleCall_1_1_2_0; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSignumExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cMultiplyExpressionOperandsAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_0_1_0 = (Group)cGroup_1_0_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_1_0_0 = (Keyword)cGroup_1_0_1_0.eContents().get(0);
		private final Assignment cOperandsAssignment_1_0_1_0_1 = (Assignment)cGroup_1_0_1_0.eContents().get(1);
		private final RuleCall cOperandsSignumExpressionParserRuleCall_1_0_1_0_1_0 = (RuleCall)cOperandsAssignment_1_0_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Alternatives cAlternatives_1_1_0 = (Alternatives)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_0_0 = (Group)cAlternatives_1_1_0.eContents().get(0);
		private final Action cDivideExpressionLeftOperandAction_1_1_0_0_0 = (Action)cGroup_1_1_0_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1_0_0_1 = (Keyword)cGroup_1_1_0_0.eContents().get(1);
		private final Group cGroup_1_1_0_1 = (Group)cAlternatives_1_1_0.eContents().get(1);
		private final Action cDivExpressionLeftOperandAction_1_1_0_1_0 = (Action)cGroup_1_1_0_1.eContents().get(0);
		private final Keyword cDivKeyword_1_1_0_1_1 = (Keyword)cGroup_1_1_0_1.eContents().get(1);
		private final Group cGroup_1_1_0_2 = (Group)cAlternatives_1_1_0.eContents().get(2);
		private final Action cModExpressionLeftOperandAction_1_1_0_2_0 = (Action)cGroup_1_1_0_2.eContents().get(0);
		private final Keyword cModKeyword_1_1_0_2_1 = (Keyword)cGroup_1_1_0_2.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRightOperandSignumExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRightOperandAssignment_1_1_1.eContents().get(0);
		
		////binary, left-associative
		//MultiplicativeExpression returns Expression:
		//	SignumExpression ({MultiplyExpression.operands+=current} => ("*" operands+=SignumExpression)+ |
		//	({DivideExpression.leftOperand=current} "/" | {DivExpression.leftOperand=current} "div" |
		//	{ModExpression.leftOperand=current} "mod") rightOperand=SignumExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//SignumExpression ({MultiplyExpression.operands+=current} => ("*" operands+=SignumExpression)+ |
		//({DivideExpression.leftOperand=current} "/" | {DivExpression.leftOperand=current} "div" |
		//{ModExpression.leftOperand=current} "mod") rightOperand=SignumExpression)*
		public Group getGroup() { return cGroup; }

		//SignumExpression
		public RuleCall getSignumExpressionParserRuleCall_0() { return cSignumExpressionParserRuleCall_0; }

		//({MultiplyExpression.operands+=current} => ("*" operands+=SignumExpression)+ | ({DivideExpression.leftOperand=current}
		//"/" | {DivExpression.leftOperand=current} "div" | {ModExpression.leftOperand=current} "mod")
		//rightOperand=SignumExpression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{MultiplyExpression.operands+=current} => ("*" operands+=SignumExpression)+
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{MultiplyExpression.operands+=current}
		public Action getMultiplyExpressionOperandsAction_1_0_0() { return cMultiplyExpressionOperandsAction_1_0_0; }

		//=> ("*" operands+=SignumExpression)+
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//"*" operands+=SignumExpression
		public Group getGroup_1_0_1_0() { return cGroup_1_0_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_1_0_0() { return cAsteriskKeyword_1_0_1_0_0; }

		//operands+=SignumExpression
		public Assignment getOperandsAssignment_1_0_1_0_1() { return cOperandsAssignment_1_0_1_0_1; }

		//SignumExpression
		public RuleCall getOperandsSignumExpressionParserRuleCall_1_0_1_0_1_0() { return cOperandsSignumExpressionParserRuleCall_1_0_1_0_1_0; }

		//({DivideExpression.leftOperand=current} "/" | {DivExpression.leftOperand=current} "div" |
		//{ModExpression.leftOperand=current} "mod") rightOperand=SignumExpression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{DivideExpression.leftOperand=current} "/" | {DivExpression.leftOperand=current} "div" |
		//{ModExpression.leftOperand=current} "mod"
		public Alternatives getAlternatives_1_1_0() { return cAlternatives_1_1_0; }

		//{DivideExpression.leftOperand=current} "/"
		public Group getGroup_1_1_0_0() { return cGroup_1_1_0_0; }

		//{DivideExpression.leftOperand=current}
		public Action getDivideExpressionLeftOperandAction_1_1_0_0_0() { return cDivideExpressionLeftOperandAction_1_1_0_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1_0_0_1() { return cSolidusKeyword_1_1_0_0_1; }

		//{DivExpression.leftOperand=current} "div"
		public Group getGroup_1_1_0_1() { return cGroup_1_1_0_1; }

		//{DivExpression.leftOperand=current}
		public Action getDivExpressionLeftOperandAction_1_1_0_1_0() { return cDivExpressionLeftOperandAction_1_1_0_1_0; }

		//"div"
		public Keyword getDivKeyword_1_1_0_1_1() { return cDivKeyword_1_1_0_1_1; }

		//{ModExpression.leftOperand=current} "mod"
		public Group getGroup_1_1_0_2() { return cGroup_1_1_0_2; }

		//{ModExpression.leftOperand=current}
		public Action getModExpressionLeftOperandAction_1_1_0_2_0() { return cModExpressionLeftOperandAction_1_1_0_2_0; }

		//"mod"
		public Keyword getModKeyword_1_1_0_2_1() { return cModKeyword_1_1_0_2_1; }

		//rightOperand=SignumExpression
		public Assignment getRightOperandAssignment_1_1_1() { return cRightOperandAssignment_1_1_1; }

		//SignumExpression
		public RuleCall getRightOperandSignumExpressionParserRuleCall_1_1_1_0() { return cRightOperandSignumExpressionParserRuleCall_1_1_1_0; }
	}

	public class SignumExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignumExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryMinusExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandSignumExpressionParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cUnaryPlusExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperandSignumExpressionParserRuleCall_1_2_0 = (RuleCall)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cAccessExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////prefix unary, right-associative
		////non-associative
		////{UnaryMinusExpression} => '-' expression=ValueAccessExpression | ValueAccessExpression
		//SignumExpression returns Expression:
		//	{UnaryMinusExpression} => "-" operand=SignumExpression | {UnaryPlusExpression} => "+" operand=SignumExpression |
		//	AccessExpression;
		@Override public ParserRule getRule() { return rule; }

		//{UnaryMinusExpression} => "-" operand=SignumExpression | {UnaryPlusExpression} => "+" operand=SignumExpression |
		//AccessExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{UnaryMinusExpression} => "-" operand=SignumExpression
		public Group getGroup_0() { return cGroup_0; }

		//{UnaryMinusExpression}
		public Action getUnaryMinusExpressionAction_0_0() { return cUnaryMinusExpressionAction_0_0; }

		//=> "-"
		public Keyword getHyphenMinusKeyword_0_1() { return cHyphenMinusKeyword_0_1; }

		//operand=SignumExpression
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }

		//SignumExpression
		public RuleCall getOperandSignumExpressionParserRuleCall_0_2_0() { return cOperandSignumExpressionParserRuleCall_0_2_0; }

		//{UnaryPlusExpression} => "+" operand=SignumExpression
		public Group getGroup_1() { return cGroup_1; }

		//{UnaryPlusExpression}
		public Action getUnaryPlusExpressionAction_1_0() { return cUnaryPlusExpressionAction_1_0; }

		//=> "+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//operand=SignumExpression
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }

		//SignumExpression
		public RuleCall getOperandSignumExpressionParserRuleCall_1_2_0() { return cOperandSignumExpressionParserRuleCall_1_2_0; }

		//AccessExpression
		public RuleCall getAccessExpressionParserRuleCall_2() { return cAccessExpressionParserRuleCall_2; }
	}

	public class AccessExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AccessExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cArrayAccessExpressionOperandAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cGroup_1_0.eContents().get(2);
		private final Assignment cParametersAssignment_1_0_2_0 = (Assignment)cGroup_1_0_2.eContents().get(0);
		private final RuleCall cParametersExpressionParserRuleCall_1_0_2_0_0 = (RuleCall)cParametersAssignment_1_0_2_0.eContents().get(0);
		private final Group cGroup_1_0_2_1 = (Group)cGroup_1_0_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_0_2_1_0 = (Keyword)cGroup_1_0_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_0_2_1_1 = (Assignment)cGroup_1_0_2_1.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_1_0_2_1_1_0 = (RuleCall)cParametersAssignment_1_0_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cFunctionAccessExpressionOperandAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Group cGroup_1_1_2 = (Group)cGroup_1_1.eContents().get(2);
		private final Assignment cParametersAssignment_1_1_2_0 = (Assignment)cGroup_1_1_2.eContents().get(0);
		private final RuleCall cParametersExpressionParserRuleCall_1_1_2_0_0 = (RuleCall)cParametersAssignment_1_1_2_0.eContents().get(0);
		private final Group cGroup_1_1_2_1 = (Group)cGroup_1_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_2_1_0 = (Keyword)cGroup_1_1_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_1_2_1_1 = (Assignment)cGroup_1_1_2_1.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_1_1_2_1_1_0 = (RuleCall)cParametersAssignment_1_1_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1_3 = (Keyword)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cRecordAccessExpressionOperandAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cFullStopKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cFieldAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cFieldIDTerminalRuleCall_1_2_2_0 = (RuleCall)cFieldAssignment_1_2_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final Action cTupleAccessExpressionOperandAction_1_3_0 = (Action)cGroup_1_3.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_3_1 = (Keyword)cGroup_1_3.eContents().get(1);
		private final Assignment cIndexAssignment_1_3_2 = (Assignment)cGroup_1_3.eContents().get(2);
		private final RuleCall cIndexINTEGERTerminalRuleCall_1_3_2_0 = (RuleCall)cIndexAssignment_1_3_2.eContents().get(0);
		private final Group cGroup_1_4 = (Group)cAlternatives_1.eContents().get(4);
		private final Action cPrimedExpressionOperandAction_1_4_0 = (Action)cGroup_1_4.eContents().get(0);
		private final Keyword cApostropheKeyword_1_4_1 = (Keyword)cGroup_1_4.eContents().get(1);
		
		////binary (postfix unary), left-associative
		//AccessExpression returns Expression:
		//	PrimaryExpression ({ArrayAccessExpression.operand=current} "[" (parameters+=Expression ("," parameters+=Expression)*)
		//	"]" | {FunctionAccessExpression.operand=current} "(" (parameters+=Expression ("," parameters+=Expression)*) ")" |
		//	{RecordAccessExpression.operand=current} "." field=ID | {TupleAccessExpression.operand=current} "!" index=INTEGER |
		//	{PrimedExpression.operand=current} "\'")*;
		@Override public ParserRule getRule() { return rule; }

		//PrimaryExpression ({ArrayAccessExpression.operand=current} "[" (parameters+=Expression ("," parameters+=Expression)*)
		//"]" | {FunctionAccessExpression.operand=current} "(" (parameters+=Expression ("," parameters+=Expression)*) ")" |
		//{RecordAccessExpression.operand=current} "." field=ID | {TupleAccessExpression.operand=current} "!" index=INTEGER |
		//{PrimedExpression.operand=current} "\'")*
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({ArrayAccessExpression.operand=current} "[" (parameters+=Expression ("," parameters+=Expression)*) "]" |
		//{FunctionAccessExpression.operand=current} "(" (parameters+=Expression ("," parameters+=Expression)*) ")" |
		//{RecordAccessExpression.operand=current} "." field=ID | {TupleAccessExpression.operand=current} "!" index=INTEGER |
		//{PrimedExpression.operand=current} "\'")*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{ArrayAccessExpression.operand=current} "[" (parameters+=Expression ("," parameters+=Expression)*) "]"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{ArrayAccessExpression.operand=current}
		public Action getArrayAccessExpressionOperandAction_1_0_0() { return cArrayAccessExpressionOperandAction_1_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0_1() { return cLeftSquareBracketKeyword_1_0_1; }

		//parameters+=Expression ("," parameters+=Expression)*
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_0_2_0() { return cParametersAssignment_1_0_2_0; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_0_2_0_0() { return cParametersExpressionParserRuleCall_1_0_2_0_0; }

		//("," parameters+=Expression)*
		public Group getGroup_1_0_2_1() { return cGroup_1_0_2_1; }

		//","
		public Keyword getCommaKeyword_1_0_2_1_0() { return cCommaKeyword_1_0_2_1_0; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_0_2_1_1() { return cParametersAssignment_1_0_2_1_1; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_0_2_1_1_0() { return cParametersExpressionParserRuleCall_1_0_2_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_0_3() { return cRightSquareBracketKeyword_1_0_3; }

		//{FunctionAccessExpression.operand=current} "(" (parameters+=Expression ("," parameters+=Expression)*) ")"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{FunctionAccessExpression.operand=current}
		public Action getFunctionAccessExpressionOperandAction_1_1_0() { return cFunctionAccessExpressionOperandAction_1_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1_1() { return cLeftParenthesisKeyword_1_1_1; }

		//parameters+=Expression ("," parameters+=Expression)*
		public Group getGroup_1_1_2() { return cGroup_1_1_2; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_1_2_0() { return cParametersAssignment_1_1_2_0; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_1_2_0_0() { return cParametersExpressionParserRuleCall_1_1_2_0_0; }

		//("," parameters+=Expression)*
		public Group getGroup_1_1_2_1() { return cGroup_1_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_1_2_1_0() { return cCommaKeyword_1_1_2_1_0; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_1_2_1_1() { return cParametersAssignment_1_1_2_1_1; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_1_2_1_1_0() { return cParametersExpressionParserRuleCall_1_1_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_1_3() { return cRightParenthesisKeyword_1_1_3; }

		//{RecordAccessExpression.operand=current} "." field=ID
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{RecordAccessExpression.operand=current}
		public Action getRecordAccessExpressionOperandAction_1_2_0() { return cRecordAccessExpressionOperandAction_1_2_0; }

		//"."
		public Keyword getFullStopKeyword_1_2_1() { return cFullStopKeyword_1_2_1; }

		//field=ID
		public Assignment getFieldAssignment_1_2_2() { return cFieldAssignment_1_2_2; }

		//ID
		public RuleCall getFieldIDTerminalRuleCall_1_2_2_0() { return cFieldIDTerminalRuleCall_1_2_2_0; }

		//{TupleAccessExpression.operand=current} "!" index=INTEGER
		public Group getGroup_1_3() { return cGroup_1_3; }

		//{TupleAccessExpression.operand=current}
		public Action getTupleAccessExpressionOperandAction_1_3_0() { return cTupleAccessExpressionOperandAction_1_3_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_3_1() { return cExclamationMarkKeyword_1_3_1; }

		//index=INTEGER
		public Assignment getIndexAssignment_1_3_2() { return cIndexAssignment_1_3_2; }

		//INTEGER
		public RuleCall getIndexINTEGERTerminalRuleCall_1_3_2_0() { return cIndexINTEGERTerminalRuleCall_1_3_2_0; }

		//{PrimedExpression.operand=current} "\'"
		public Group getGroup_1_4() { return cGroup_1_4; }

		//{PrimedExpression.operand=current}
		public Action getPrimedExpressionOperandAction_1_4_0() { return cPrimedExpressionOperandAction_1_4_0; }

		//"\'"
		public Keyword getApostropheKeyword_1_4_1() { return cApostropheKeyword_1_4_1; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReferenceExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//////postfix unary, non-associative
		////PrimedExpression returns Expression:
		////	PrimaryExpression ({PrimedExpression.operand=current} '^')?
		////	//left-associative
		////	//ValueAccessExpression ({PrimedExpression.expression=current} '^')*
		////;
		//PrimaryExpression returns Expression:
		//	LiteralExpression | ReferenceExpression | "(" Expression ")";
		@Override public ParserRule getRule() { return rule; }

		//LiteralExpression | ReferenceExpression | "(" Expression ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_0() { return cLiteralExpressionParserRuleCall_0; }

		//ReferenceExpression
		public RuleCall getReferenceExpressionParserRuleCall_1() { return cReferenceExpressionParserRuleCall_1; }

		//"(" Expression ")"
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_2_1() { return cExpressionParserRuleCall_2_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class ReferenceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReferenceExpression");
		private final Assignment cDeclarationAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cDeclarationDeclarationCrossReference_0 = (CrossReference)cDeclarationAssignment.eContents().get(0);
		private final RuleCall cDeclarationDeclarationIDTerminalRuleCall_0_1 = (RuleCall)cDeclarationDeclarationCrossReference_0.eContents().get(1);
		
		//ReferenceExpression:
		//	declaration=[Declaration];
		@Override public ParserRule getRule() { return rule; }

		//declaration=[Declaration]
		public Assignment getDeclarationAssignment() { return cDeclarationAssignment; }

		//[Declaration]
		public CrossReference getDeclarationDeclarationCrossReference_0() { return cDeclarationDeclarationCrossReference_0; }

		//ID
		public RuleCall getDeclarationDeclarationIDTerminalRuleCall_0_1() { return cDeclarationDeclarationIDTerminalRuleCall_0_1; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegerLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDecimalLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRationalLiteralExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBooleanLiteralExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cArrayLiteralExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cRecordLiteralExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cTupleLiteralExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cEnumerationLiteralExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//LiteralExpression returns Expression:
		//	IntegerLiteralExpression | DecimalLiteralExpression | RationalLiteralExpression | BooleanLiteralExpression |
		//	ArrayLiteralExpression | RecordLiteralExpression | TupleLiteralExpression | EnumerationLiteralExpression;
		@Override public ParserRule getRule() { return rule; }

		//IntegerLiteralExpression | DecimalLiteralExpression | RationalLiteralExpression | BooleanLiteralExpression |
		//ArrayLiteralExpression | RecordLiteralExpression | TupleLiteralExpression | EnumerationLiteralExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntegerLiteralExpression
		public RuleCall getIntegerLiteralExpressionParserRuleCall_0() { return cIntegerLiteralExpressionParserRuleCall_0; }

		//DecimalLiteralExpression
		public RuleCall getDecimalLiteralExpressionParserRuleCall_1() { return cDecimalLiteralExpressionParserRuleCall_1; }

		//RationalLiteralExpression
		public RuleCall getRationalLiteralExpressionParserRuleCall_2() { return cRationalLiteralExpressionParserRuleCall_2; }

		//BooleanLiteralExpression
		public RuleCall getBooleanLiteralExpressionParserRuleCall_3() { return cBooleanLiteralExpressionParserRuleCall_3; }

		//ArrayLiteralExpression
		public RuleCall getArrayLiteralExpressionParserRuleCall_4() { return cArrayLiteralExpressionParserRuleCall_4; }

		//RecordLiteralExpression
		public RuleCall getRecordLiteralExpressionParserRuleCall_5() { return cRecordLiteralExpressionParserRuleCall_5; }

		//TupleLiteralExpression
		public RuleCall getTupleLiteralExpressionParserRuleCall_6() { return cTupleLiteralExpressionParserRuleCall_6; }

		//EnumerationLiteralExpression
		public RuleCall getEnumerationLiteralExpressionParserRuleCall_7() { return cEnumerationLiteralExpressionParserRuleCall_7; }
	}

	public class IntegerLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTEGERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntegerLiteralExpression:
		//	value=INTEGER;
		@Override public ParserRule getRule() { return rule; }

		//value=INTEGER
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INTEGER
		public RuleCall getValueINTEGERTerminalRuleCall_0() { return cValueINTEGERTerminalRuleCall_0; }
	}

	public class DecimalLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DecimalLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDECIMALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DecimalLiteralExpression:
		//	value=DECIMAL;
		@Override public ParserRule getRule() { return rule; }

		//value=DECIMAL
		public Assignment getValueAssignment() { return cValueAssignment; }

		//DECIMAL
		public RuleCall getValueDECIMALTerminalRuleCall_0() { return cValueDECIMALTerminalRuleCall_0; }
	}

	public class RationalLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RationalLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNumeratorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNumeratorINTEGERTerminalRuleCall_0_0 = (RuleCall)cNumeratorAssignment_0.eContents().get(0);
		private final Keyword cPercentSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDenominatorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDenominatorINTEGERTerminalRuleCall_2_0 = (RuleCall)cDenominatorAssignment_2.eContents().get(0);
		
		//RationalLiteralExpression:
		//	numerator=INTEGER "%" denominator=INTEGER;
		@Override public ParserRule getRule() { return rule; }

		//numerator=INTEGER "%" denominator=INTEGER
		public Group getGroup() { return cGroup; }

		//numerator=INTEGER
		public Assignment getNumeratorAssignment_0() { return cNumeratorAssignment_0; }

		//INTEGER
		public RuleCall getNumeratorINTEGERTerminalRuleCall_0_0() { return cNumeratorINTEGERTerminalRuleCall_0_0; }

		//"%"
		public Keyword getPercentSignKeyword_1() { return cPercentSignKeyword_1; }

		//denominator=INTEGER
		public Assignment getDenominatorAssignment_2() { return cDenominatorAssignment_2; }

		//INTEGER
		public RuleCall getDenominatorINTEGERTerminalRuleCall_2_0() { return cDenominatorINTEGERTerminalRuleCall_2_0; }
	}

	public class BooleanLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTrueExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFalseExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BooleanLiteralExpression:
		//	TrueExpression | FalseExpression;
		@Override public ParserRule getRule() { return rule; }

		//TrueExpression | FalseExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//TrueExpression
		public RuleCall getTrueExpressionParserRuleCall_0() { return cTrueExpressionParserRuleCall_0; }

		//FalseExpression
		public RuleCall getFalseExpressionParserRuleCall_1() { return cFalseExpressionParserRuleCall_1; }
	}

	public class TrueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrueExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrueExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TrueExpression:
		//	{TrueExpression} "true";
		@Override public ParserRule getRule() { return rule; }

		//{TrueExpression} "true"
		public Group getGroup() { return cGroup; }

		//{TrueExpression}
		public Action getTrueExpressionAction_0() { return cTrueExpressionAction_0; }

		//"true"
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
	}

	public class FalseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FalseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFalseExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//FalseExpression:
		//	{FalseExpression} "false";
		@Override public ParserRule getRule() { return rule; }

		//{FalseExpression} "false"
		public Group getGroup() { return cGroup; }

		//{FalseExpression}
		public Action getFalseExpressionAction_0() { return cFalseExpressionAction_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class ArrayLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cParameterDeclarationsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_1_0_0 = (RuleCall)cParameterDeclarationsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cParameterDeclarationsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cParameterDeclarationsParameterDeclarationParserRuleCall_1_1_1_0 = (RuleCall)cParameterDeclarationsAssignment_1_1_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOperandAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOperandExpressionParserRuleCall_3_0 = (RuleCall)cOperandAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ArrayLiteralExpression:
		//	"[" (parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)? "|"
		//	operand=Expression "]";
		@Override public ParserRule getRule() { return rule; }

		//"[" (parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)? "|"
		//operand=Expression "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//(parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)?
		public Group getGroup_1() { return cGroup_1; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_1_0() { return cParameterDeclarationsAssignment_1_0; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_1_0_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_1_0_0; }

		//("," parameterDeclarations+=ParameterDeclaration)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//parameterDeclarations+=ParameterDeclaration
		public Assignment getParameterDeclarationsAssignment_1_1_1() { return cParameterDeclarationsAssignment_1_1_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationsParameterDeclarationParserRuleCall_1_1_1_0() { return cParameterDeclarationsParameterDeclarationParserRuleCall_1_1_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }

		//operand=Expression
		public Assignment getOperandAssignment_3() { return cOperandAssignment_3; }

		//Expression
		public RuleCall getOperandExpressionParserRuleCall_3_0() { return cOperandExpressionParserRuleCall_3_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}

	public class RecordLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RecordLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFieldAssignmentsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldAssignmentsFieldAssignmentParserRuleCall_1_0 = (RuleCall)cFieldAssignmentsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cFieldAssignmentsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFieldAssignmentsFieldAssignmentParserRuleCall_2_1_0 = (RuleCall)cFieldAssignmentsAssignment_2_1.eContents().get(0);
		private final Keyword cNumberSignRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RecordLiteralExpression:
		//	"(#" fieldAssignments+=FieldAssignment ("," fieldAssignments+=FieldAssignment)* "#)";
		@Override public ParserRule getRule() { return rule; }

		//"(#" fieldAssignments+=FieldAssignment ("," fieldAssignments+=FieldAssignment)* "#)"
		public Group getGroup() { return cGroup; }

		//"(#"
		public Keyword getLeftParenthesisNumberSignKeyword_0() { return cLeftParenthesisNumberSignKeyword_0; }

		//fieldAssignments+=FieldAssignment
		public Assignment getFieldAssignmentsAssignment_1() { return cFieldAssignmentsAssignment_1; }

		//FieldAssignment
		public RuleCall getFieldAssignmentsFieldAssignmentParserRuleCall_1_0() { return cFieldAssignmentsFieldAssignmentParserRuleCall_1_0; }

		//("," fieldAssignments+=FieldAssignment)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//fieldAssignments+=FieldAssignment
		public Assignment getFieldAssignmentsAssignment_2_1() { return cFieldAssignmentsAssignment_2_1; }

		//FieldAssignment
		public RuleCall getFieldAssignmentsFieldAssignmentParserRuleCall_2_1_0() { return cFieldAssignmentsFieldAssignmentParserRuleCall_2_1_0; }

		//"#)"
		public Keyword getNumberSignRightParenthesisKeyword_3() { return cNumberSignRightParenthesisKeyword_3; }
	}

	public class FieldAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FieldAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cReferenceIDTerminalRuleCall_0_0 = (RuleCall)cReferenceAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//FieldAssignment:
		//	reference=ID ":=" value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//reference=ID ":=" value=Expression
		public Group getGroup() { return cGroup; }

		//reference=ID
		public Assignment getReferenceAssignment_0() { return cReferenceAssignment_0; }

		//ID
		public RuleCall getReferenceIDTerminalRuleCall_0_0() { return cReferenceIDTerminalRuleCall_0_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }

		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
	}

	public class TupleLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		private final Keyword cNumberSignRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TupleLiteralExpression:
		//	"(#" expressions+=Expression ("," expressions+=Expression)* "#)";
		@Override public ParserRule getRule() { return rule; }

		//"(#" expressions+=Expression ("," expressions+=Expression)* "#)"
		public Group getGroup() { return cGroup; }

		//"(#"
		public Keyword getLeftParenthesisNumberSignKeyword_0() { return cLeftParenthesisNumberSignKeyword_0; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_0() { return cExpressionsExpressionParserRuleCall_1_0; }

		//("," expressions+=Expression)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_2_1_0() { return cExpressionsExpressionParserRuleCall_2_1_0; }

		//"#)"
		public Keyword getNumberSignRightParenthesisKeyword_3() { return cNumberSignRightParenthesisKeyword_3; }
	}

	public class EnumerationLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReferenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cReferenceEnumerationLiteralDefinitionCrossReference_1_0 = (CrossReference)cReferenceAssignment_1.eContents().get(0);
		private final RuleCall cReferenceEnumerationLiteralDefinitionIDTerminalRuleCall_1_0_1 = (RuleCall)cReferenceEnumerationLiteralDefinitionCrossReference_1_0.eContents().get(1);
		
		//EnumerationLiteralExpression:
		//	"::" reference=[EnumerationLiteralDefinition];
		@Override public ParserRule getRule() { return rule; }

		//"::" reference=[EnumerationLiteralDefinition]
		public Group getGroup() { return cGroup; }

		//"::"
		public Keyword getColonColonKeyword_0() { return cColonColonKeyword_0; }

		//reference=[EnumerationLiteralDefinition]
		public Assignment getReferenceAssignment_1() { return cReferenceAssignment_1; }

		//[EnumerationLiteralDefinition]
		public CrossReference getReferenceEnumerationLiteralDefinitionCrossReference_1_0() { return cReferenceEnumerationLiteralDefinitionCrossReference_1_0; }

		//ID
		public RuleCall getReferenceEnumerationLiteralDefinitionIDTerminalRuleCall_1_0_1() { return cReferenceEnumerationLiteralDefinitionIDTerminalRuleCall_1_0_1; }
	}

	public class BasicConstraintDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicConstraintDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		/////////////////////////////////
		//// Basic Constraint
		/////////////////////////////////
		//BasicConstraintDefinition:
		//	"constraint" expression=Expression;
		@Override public ParserRule getRule() { return rule; }

		//"constraint" expression=Expression
		public Group getGroup() { return cGroup; }

		//"constraint"
		public Keyword getConstraintKeyword_0() { return cConstraintKeyword_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
	}
	
	
	private final ConstraintSpecificationElements pConstraintSpecification;
	private final ParameterDeclarationElements pParameterDeclaration;
	private final FieldDeclarationElements pFieldDeclaration;
	private final LetDeclarationElements pLetDeclaration;
	private final ConstantDeclarationElements pConstantDeclaration;
	private final FunctionDeclarationElements pFunctionDeclaration;
	private final TypeElements pType;
	private final TypeDeclarationElements pTypeDeclaration;
	private final TypeReferenceElements pTypeReference;
	private final TypeDefinitionElements pTypeDefinition;
	private final NaturalTypeDefinitionElements pNaturalTypeDefinition;
	private final IntegerTypeDefinitionElements pIntegerTypeDefinition;
	private final BooleanTypeDefinitionElements pBooleanTypeDefinition;
	private final RealTypeDefinitionElements pRealTypeDefinition;
	private final ArrayTypeDefinitionElements pArrayTypeDefinition;
	private final EnumerationTypeDefinitionElements pEnumerationTypeDefinition;
	private final EnumerationLiteralDefinitionElements pEnumerationLiteralDefinition;
	private final RecordTypeDefinitionElements pRecordTypeDefinition;
	private final TupleTypeDefinitionElements pTupleTypeDefinition;
	private final SubrangeTypeDefinitionElements pSubrangeTypeDefinition;
	private final SubTypeDefinitionElements pSubTypeDefinition;
	private final FunctionTypeDefinitionElements pFunctionTypeDefinition;
	private final ExpressionElements pExpression;
	private final IfThenElseExpressionElements pIfThenElseExpression;
	private final EqualExpressionElements pEqualExpression;
	private final ImplyExpressionElements pImplyExpression;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final ReleaseExpressionElements pReleaseExpression;
	private final UntilExpressionElements pUntilExpression;
	private final UnaryLogicExpressionElements pUnaryLogicExpression;
	private final NotExpressionElements pNotExpression;
	private final ForallExpressionElements pForallExpression;
	private final ExistsExpressionElements pExistsExpression;
	private final FunctionLiteralExpressionElements pFunctionLiteralExpression;
	private final GloballyExpressionElements pGloballyExpression;
	private final FinallyExpressionElements pFinallyExpression;
	private final NextExpressionElements pNextExpression;
	private final TemporalForallExpressionElements pTemporalForallExpression;
	private final TemporalExistsExpressionElements pTemporalExistsExpression;
	private final LetExpressionElements pLetExpression;
	private final InExpressionElements pInExpression;
	private final EquivalenceExpressionElements pEquivalenceExpression;
	private final ComparisionExpressionElements pComparisionExpression;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final SignumExpressionElements pSignumExpression;
	private final AccessExpressionElements pAccessExpression;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final ReferenceExpressionElements pReferenceExpression;
	private final LiteralExpressionElements pLiteralExpression;
	private final IntegerLiteralExpressionElements pIntegerLiteralExpression;
	private final DecimalLiteralExpressionElements pDecimalLiteralExpression;
	private final RationalLiteralExpressionElements pRationalLiteralExpression;
	private final BooleanLiteralExpressionElements pBooleanLiteralExpression;
	private final TrueExpressionElements pTrueExpression;
	private final FalseExpressionElements pFalseExpression;
	private final ArrayLiteralExpressionElements pArrayLiteralExpression;
	private final RecordLiteralExpressionElements pRecordLiteralExpression;
	private final FieldAssignmentElements pFieldAssignment;
	private final TupleLiteralExpressionElements pTupleLiteralExpression;
	private final EnumerationLiteralExpressionElements pEnumerationLiteralExpression;
	private final BasicConstraintDefinitionElements pBasicConstraintDefinition;
	private final TerminalRule tINT;
	private final TerminalRule tSTRING;
	private final TerminalRule tINTEGER;
	private final TerminalRule tDECIMAL;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public TTMCConstraintLanguageGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pConstraintSpecification = new ConstraintSpecificationElements();
		this.pParameterDeclaration = new ParameterDeclarationElements();
		this.pFieldDeclaration = new FieldDeclarationElements();
		this.pLetDeclaration = new LetDeclarationElements();
		this.pConstantDeclaration = new ConstantDeclarationElements();
		this.pFunctionDeclaration = new FunctionDeclarationElements();
		this.pType = new TypeElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pTypeReference = new TypeReferenceElements();
		this.pTypeDefinition = new TypeDefinitionElements();
		this.pNaturalTypeDefinition = new NaturalTypeDefinitionElements();
		this.pIntegerTypeDefinition = new IntegerTypeDefinitionElements();
		this.pBooleanTypeDefinition = new BooleanTypeDefinitionElements();
		this.pRealTypeDefinition = new RealTypeDefinitionElements();
		this.pArrayTypeDefinition = new ArrayTypeDefinitionElements();
		this.pEnumerationTypeDefinition = new EnumerationTypeDefinitionElements();
		this.pEnumerationLiteralDefinition = new EnumerationLiteralDefinitionElements();
		this.pRecordTypeDefinition = new RecordTypeDefinitionElements();
		this.pTupleTypeDefinition = new TupleTypeDefinitionElements();
		this.pSubrangeTypeDefinition = new SubrangeTypeDefinitionElements();
		this.pSubTypeDefinition = new SubTypeDefinitionElements();
		this.pFunctionTypeDefinition = new FunctionTypeDefinitionElements();
		this.pExpression = new ExpressionElements();
		this.pIfThenElseExpression = new IfThenElseExpressionElements();
		this.pEqualExpression = new EqualExpressionElements();
		this.pImplyExpression = new ImplyExpressionElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pReleaseExpression = new ReleaseExpressionElements();
		this.pUntilExpression = new UntilExpressionElements();
		this.pUnaryLogicExpression = new UnaryLogicExpressionElements();
		this.pNotExpression = new NotExpressionElements();
		this.pForallExpression = new ForallExpressionElements();
		this.pExistsExpression = new ExistsExpressionElements();
		this.pFunctionLiteralExpression = new FunctionLiteralExpressionElements();
		this.pGloballyExpression = new GloballyExpressionElements();
		this.pFinallyExpression = new FinallyExpressionElements();
		this.pNextExpression = new NextExpressionElements();
		this.pTemporalForallExpression = new TemporalForallExpressionElements();
		this.pTemporalExistsExpression = new TemporalExistsExpressionElements();
		this.pLetExpression = new LetExpressionElements();
		this.pInExpression = new InExpressionElements();
		this.pEquivalenceExpression = new EquivalenceExpressionElements();
		this.pComparisionExpression = new ComparisionExpressionElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pSignumExpression = new SignumExpressionElements();
		this.pAccessExpression = new AccessExpressionElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pReferenceExpression = new ReferenceExpressionElements();
		this.pLiteralExpression = new LiteralExpressionElements();
		this.pIntegerLiteralExpression = new IntegerLiteralExpressionElements();
		this.pDecimalLiteralExpression = new DecimalLiteralExpressionElements();
		this.pRationalLiteralExpression = new RationalLiteralExpressionElements();
		this.pBooleanLiteralExpression = new BooleanLiteralExpressionElements();
		this.pTrueExpression = new TrueExpressionElements();
		this.pFalseExpression = new FalseExpressionElements();
		this.pArrayLiteralExpression = new ArrayLiteralExpressionElements();
		this.pRecordLiteralExpression = new RecordLiteralExpressionElements();
		this.pFieldAssignment = new FieldAssignmentElements();
		this.pTupleLiteralExpression = new TupleLiteralExpressionElements();
		this.pEnumerationLiteralExpression = new EnumerationLiteralExpressionElements();
		this.pBasicConstraintDefinition = new BasicConstraintDefinitionElements();
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING");
		this.tINTEGER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTEGER");
		this.tDECIMAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DECIMAL");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("hu.bme.mit.inf.ttmc.constraint.language.TTMCConstraintLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/////////////////////////////////////////////
	//ConstraintSpecification:
	//	"specification" name=ID ("(" (parameterDeclarations+=ParameterDeclaration (","
	//	parameterDeclarations+=ParameterDeclaration)*)? ")")? "{" (typeDeclarations+=TypeDeclaration |
	//	constantDeclarations+=ConstantDeclaration | functionDeclarations+=FunctionDeclaration |
	//	basicConstraintDefinitions+=BasicConstraintDefinition)* "}";
	public ConstraintSpecificationElements getConstraintSpecificationAccess() {
		return pConstraintSpecification;
	}
	
	public ParserRule getConstraintSpecificationRule() {
		return getConstraintSpecificationAccess().getRule();
	}

	/////////////////////////////////////////////
	//ParameterDeclaration:
	//	{ParameterDeclaration} name=ID ":" type=Type;
	public ParameterDeclarationElements getParameterDeclarationAccess() {
		return pParameterDeclaration;
	}
	
	public ParserRule getParameterDeclarationRule() {
		return getParameterDeclarationAccess().getRule();
	}

	//FieldDeclaration:
	//	{FieldDeclaration} name=ID ":" type=Type;
	public FieldDeclarationElements getFieldDeclarationAccess() {
		return pFieldDeclaration;
	}
	
	public ParserRule getFieldDeclarationRule() {
		return getFieldDeclarationAccess().getRule();
	}

	//LetDeclaration:
	//	{LetDeclaration} name=ID ":" type=Type ":=" expression=Expression;
	public LetDeclarationElements getLetDeclarationAccess() {
		return pLetDeclaration;
	}
	
	public ParserRule getLetDeclarationRule() {
		return getLetDeclarationAccess().getRule();
	}

	//ConstantDeclaration:
	//	"const" name=ID ":" type=Type (":=" expression=Expression)?;
	public ConstantDeclarationElements getConstantDeclarationAccess() {
		return pConstantDeclaration;
	}
	
	public ParserRule getConstantDeclarationRule() {
		return getConstantDeclarationAccess().getRule();
	}

	//FunctionDeclaration:
	//	"function" name=ID ("(" (parameterDeclarations+=ParameterDeclaration (","
	//	parameterDeclarations+=ParameterDeclaration)*)? ")")? ":" type=Type (":=" expression=Expression)?;
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return pFunctionDeclaration;
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//////////////////////////////////////////
	//// Type language
	//////////////////////////////////////////
	//Type:
	//	TypeReference | TypeDefinition;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//TypeDeclaration:
	//	"type" name=ID ":" type=Type;
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	//TypeReference:
	//	reference=[TypeDeclaration];
	public TypeReferenceElements getTypeReferenceAccess() {
		return pTypeReference;
	}
	
	public ParserRule getTypeReferenceRule() {
		return getTypeReferenceAccess().getRule();
	}

	//TypeDefinition:
	//	NaturalTypeDefinition | IntegerTypeDefinition | BooleanTypeDefinition | RealTypeDefinition | ArrayTypeDefinition |
	//	EnumerationTypeDefinition | RecordTypeDefinition | TupleTypeDefinition | SubrangeTypeDefinition | SubTypeDefinition |
	//	FunctionTypeDefinition;
	public TypeDefinitionElements getTypeDefinitionAccess() {
		return pTypeDefinition;
	}
	
	public ParserRule getTypeDefinitionRule() {
		return getTypeDefinitionAccess().getRule();
	}

	//NaturalTypeDefinition returns BasicTypeDefinition:
	//	{NaturalTypeDefinition} "natural";
	public NaturalTypeDefinitionElements getNaturalTypeDefinitionAccess() {
		return pNaturalTypeDefinition;
	}
	
	public ParserRule getNaturalTypeDefinitionRule() {
		return getNaturalTypeDefinitionAccess().getRule();
	}

	//IntegerTypeDefinition returns BasicTypeDefinition:
	//	{IntegerTypeDefinition} "integer";
	public IntegerTypeDefinitionElements getIntegerTypeDefinitionAccess() {
		return pIntegerTypeDefinition;
	}
	
	public ParserRule getIntegerTypeDefinitionRule() {
		return getIntegerTypeDefinitionAccess().getRule();
	}

	//BooleanTypeDefinition returns BasicTypeDefinition:
	//	{BooleanTypeDefinition} "boolean";
	public BooleanTypeDefinitionElements getBooleanTypeDefinitionAccess() {
		return pBooleanTypeDefinition;
	}
	
	public ParserRule getBooleanTypeDefinitionRule() {
		return getBooleanTypeDefinitionAccess().getRule();
	}

	//RealTypeDefinition:
	//	{RealTypeDefinition} "real";
	public RealTypeDefinitionElements getRealTypeDefinitionAccess() {
		return pRealTypeDefinition;
	}
	
	public ParserRule getRealTypeDefinitionRule() {
		return getRealTypeDefinitionAccess().getRule();
	}

	//ArrayTypeDefinition:
	//	"array" indexTypes+=Type ("," indexTypes+=Type)* "of" elementType=Type;
	public ArrayTypeDefinitionElements getArrayTypeDefinitionAccess() {
		return pArrayTypeDefinition;
	}
	
	public ParserRule getArrayTypeDefinitionRule() {
		return getArrayTypeDefinitionAccess().getRule();
	}

	//EnumerationTypeDefinition:
	//	"enum" "{" literals+=EnumerationLiteralDefinition ("," literals+=EnumerationLiteralDefinition)* "}";
	public EnumerationTypeDefinitionElements getEnumerationTypeDefinitionAccess() {
		return pEnumerationTypeDefinition;
	}
	
	public ParserRule getEnumerationTypeDefinitionRule() {
		return getEnumerationTypeDefinitionAccess().getRule();
	}

	//EnumerationLiteralDefinition:
	//	name=ID;
	public EnumerationLiteralDefinitionElements getEnumerationLiteralDefinitionAccess() {
		return pEnumerationLiteralDefinition;
	}
	
	public ParserRule getEnumerationLiteralDefinitionRule() {
		return getEnumerationLiteralDefinitionAccess().getRule();
	}

	//RecordTypeDefinition:
	//	"record" "{" fieldDeclarations+=FieldDeclaration ("," fieldDeclarations+=FieldDeclaration)* "}";
	public RecordTypeDefinitionElements getRecordTypeDefinitionAccess() {
		return pRecordTypeDefinition;
	}
	
	public ParserRule getRecordTypeDefinitionRule() {
		return getRecordTypeDefinitionAccess().getRule();
	}

	//TupleTypeDefinition:
	//	"tuple" "{" types+=Type ("," types+=Type)* "}";
	public TupleTypeDefinitionElements getTupleTypeDefinitionAccess() {
		return pTupleTypeDefinition;
	}
	
	public ParserRule getTupleTypeDefinitionRule() {
		return getTupleTypeDefinitionAccess().getRule();
	}

	//SubrangeTypeDefinition:
	//	{SubrangeTypeDefinition} "[" ("-" "inf" | lowerBound=Expression) "to" ("inf" | upperBound=Expression) "]";
	public SubrangeTypeDefinitionElements getSubrangeTypeDefinitionAccess() {
		return pSubrangeTypeDefinition;
	}
	
	public ParserRule getSubrangeTypeDefinitionRule() {
		return getSubrangeTypeDefinitionAccess().getRule();
	}

	//SubTypeDefinition:
	//	"{" parameterDeclaration=ParameterDeclaration "|" expression=Expression "}";
	public SubTypeDefinitionElements getSubTypeDefinitionAccess() {
		return pSubTypeDefinition;
	}
	
	public ParserRule getSubTypeDefinitionRule() {
		return getSubTypeDefinitionAccess().getRule();
	}

	//FunctionTypeDefinition:
	//	"function" "(" (parameterTypes+=Type ("," parameterTypes+=Type)*)? ")" ":" returnType=Type;
	public FunctionTypeDefinitionElements getFunctionTypeDefinitionAccess() {
		return pFunctionTypeDefinition;
	}
	
	public ParserRule getFunctionTypeDefinitionRule() {
		return getFunctionTypeDefinitionAccess().getRule();
	}

	//////////////////////////////////////////
	//// Expression language
	//////////////////////////////////////////
	//Expression:
	//	IfThenElseExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	////ternary, right-associative
	//IfThenElseExpression returns Expression:
	//	{IfThenElseExpression} "if" condition=Expression "then" then=Expression ("else" else=Expression) | EqualExpression;
	public IfThenElseExpressionElements getIfThenElseExpressionAccess() {
		return pIfThenElseExpression;
	}
	
	public ParserRule getIfThenElseExpressionRule() {
		return getIfThenElseExpressionAccess().getRule();
	}

	////binary, right-associative
	//EqualExpression returns Expression:
	//	ImplyExpression ({EqualExpression.leftOperand=current} "equal" rightOperand=EqualExpression)?;
	public EqualExpressionElements getEqualExpressionAccess() {
		return pEqualExpression;
	}
	
	public ParserRule getEqualExpressionRule() {
		return getEqualExpressionAccess().getRule();
	}

	////binary, right-associative
	//ImplyExpression returns Expression:
	//	OrExpression ({ImplyExpression.leftOperand=current} "imply" rightOperand=ImplyExpression)?;
	public ImplyExpressionElements getImplyExpressionAccess() {
		return pImplyExpression;
	}
	
	public ParserRule getImplyExpressionRule() {
		return getImplyExpressionAccess().getRule();
	}

	////multiary
	//OrExpression returns Expression:
	//	AndExpression ({OrExpression.operands+=current} ("or" operands+=AndExpression)+)?;
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	////multiary
	//AndExpression returns Expression:
	//	ReleaseExpression ({AndExpression.operands+=current} ("and" operands+=ReleaseExpression)+)?;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	////binary, left-associative
	//ReleaseExpression returns Expression:
	//	UntilExpression ({ReleaseExpression.leftOperand=current} "R" rightOperand=UntilExpression)*;
	public ReleaseExpressionElements getReleaseExpressionAccess() {
		return pReleaseExpression;
	}
	
	public ParserRule getReleaseExpressionRule() {
		return getReleaseExpressionAccess().getRule();
	}

	////binary, left-associative
	//UntilExpression returns Expression:
	//	UnaryLogicExpression ({UntilExpression.leftOperand=current} "U" rightOperand=UnaryLogicExpression)*;
	public UntilExpressionElements getUntilExpressionAccess() {
		return pUntilExpression;
	}
	
	public ParserRule getUntilExpressionRule() {
		return getUntilExpressionAccess().getRule();
	}

	////prefix unary, right-associative
	//UnaryLogicExpression returns Expression:
	//	NotExpression | ForallExpression | ExistsExpression | FunctionLiteralExpression | GloballyExpression |
	//	FinallyExpression | NextExpression | TemporalForallExpression | TemporalExistsExpression | LetExpression |
	//	InExpression;
	public UnaryLogicExpressionElements getUnaryLogicExpressionAccess() {
		return pUnaryLogicExpression;
	}
	
	public ParserRule getUnaryLogicExpressionRule() {
		return getUnaryLogicExpressionAccess().getRule();
	}

	//NotExpression returns Expression:
	//	{NotExpression} => "not" operand=UnaryLogicExpression;
	public NotExpressionElements getNotExpressionAccess() {
		return pNotExpression;
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//ForallExpression returns Expression:
	//	{ForallExpression} => "forall" "(" (parameterDeclarations+=ParameterDeclaration (","
	//	parameterDeclarations+=ParameterDeclaration)*)? ")" ":" operand=UnaryLogicExpression;
	public ForallExpressionElements getForallExpressionAccess() {
		return pForallExpression;
	}
	
	public ParserRule getForallExpressionRule() {
		return getForallExpressionAccess().getRule();
	}

	//ExistsExpression returns Expression:
	//	{ExistsExpression} => "exists" "(" (parameterDeclarations+=ParameterDeclaration (","
	//	parameterDeclarations+=ParameterDeclaration)*)? ")" ":" operand=UnaryLogicExpression;
	public ExistsExpressionElements getExistsExpressionAccess() {
		return pExistsExpression;
	}
	
	public ParserRule getExistsExpressionRule() {
		return getExistsExpressionAccess().getRule();
	}

	//FunctionLiteralExpression returns Expression:
	//	{FunctionLiteralExpression} => "function" "(" (parameterDeclarations+=ParameterDeclaration (","
	//	parameterDeclarations+=ParameterDeclaration)*)? ")" ":" returnType=Type ":=" operand=UnaryLogicExpression;
	public FunctionLiteralExpressionElements getFunctionLiteralExpressionAccess() {
		return pFunctionLiteralExpression;
	}
	
	public ParserRule getFunctionLiteralExpressionRule() {
		return getFunctionLiteralExpressionAccess().getRule();
	}

	//GloballyExpression returns Expression:
	//	{GloballyExpression} => "G" operand=UnaryLogicExpression;
	public GloballyExpressionElements getGloballyExpressionAccess() {
		return pGloballyExpression;
	}
	
	public ParserRule getGloballyExpressionRule() {
		return getGloballyExpressionAccess().getRule();
	}

	//FinallyExpression returns Expression:
	//	{FinallyExpression} => "F" operand=UnaryLogicExpression;
	public FinallyExpressionElements getFinallyExpressionAccess() {
		return pFinallyExpression;
	}
	
	public ParserRule getFinallyExpressionRule() {
		return getFinallyExpressionAccess().getRule();
	}

	//NextExpression returns Expression:
	//	{NextExpression} => "X" operand=UnaryLogicExpression;
	public NextExpressionElements getNextExpressionAccess() {
		return pNextExpression;
	}
	
	public ParserRule getNextExpressionRule() {
		return getNextExpressionAccess().getRule();
	}

	//TemporalForallExpression returns Expression:
	//	{TemporalForallExpression} => "A" operand=UnaryLogicExpression;
	public TemporalForallExpressionElements getTemporalForallExpressionAccess() {
		return pTemporalForallExpression;
	}
	
	public ParserRule getTemporalForallExpressionRule() {
		return getTemporalForallExpressionAccess().getRule();
	}

	//TemporalExistsExpression returns Expression:
	//	{TemporalExistsExpression} => "E" operand=UnaryLogicExpression;
	public TemporalExistsExpressionElements getTemporalExistsExpressionAccess() {
		return pTemporalExistsExpression;
	}
	
	public ParserRule getTemporalExistsExpressionRule() {
		return getTemporalExistsExpressionAccess().getRule();
	}

	//LetExpression returns Expression:
	//	{LetExpression} "let" "(" letDeclarations+=LetDeclaration ("," letDeclarations+=LetDeclaration)* ")" "in"
	//	expression=UnaryLogicExpression;
	public LetExpressionElements getLetExpressionAccess() {
		return pLetExpression;
	}
	
	public ParserRule getLetExpressionRule() {
		return getLetExpressionAccess().getRule();
	}

	////postfix unary, non-associative
	//InExpression returns Expression:
	//	EquivalenceExpression ({InExpression.operand=current} "in" type=Type)?;
	public InExpressionElements getInExpressionAccess() {
		return pInExpression;
	}
	
	public ParserRule getInExpressionRule() {
		return getInExpressionAccess().getRule();
	}

	////binary, non-associative
	//EquivalenceExpression returns Expression:
	//	ComparisionExpression ({EqualityExpression.leftOperand=current} "=" rightOperand=ComparisionExpression |
	//	{InequalityExpression.leftOperand=current} "/=" rightOperand=ComparisionExpression)?;
	public EquivalenceExpressionElements getEquivalenceExpressionAccess() {
		return pEquivalenceExpression;
	}
	
	public ParserRule getEquivalenceExpressionRule() {
		return getEquivalenceExpressionAccess().getRule();
	}

	////binary, non-associative
	//ComparisionExpression returns Expression:
	//	AdditiveExpression (({GreaterExpression.leftOperand=current} ">" | {GreaterEqualExpression.leftOperand=current} ">=" |
	//	{LessExpression.leftOperand=current} "<" | {LessEqualExpression.leftOperand=current} "<=")
	//	rightOperand=AdditiveExpression)*;
	public ComparisionExpressionElements getComparisionExpressionAccess() {
		return pComparisionExpression;
	}
	
	public ParserRule getComparisionExpressionRule() {
		return getComparisionExpressionAccess().getRule();
	}

	////binary, left-associative
	//AdditiveExpression returns Expression:
	//	MultiplicativeExpression ({AddExpression.operands+=current} => ("+" operands+=MultiplicativeExpression)+ |
	//	{SubtractExpression.leftOperand=current} "-" rightOperand=MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	////binary, left-associative
	//MultiplicativeExpression returns Expression:
	//	SignumExpression ({MultiplyExpression.operands+=current} => ("*" operands+=SignumExpression)+ |
	//	({DivideExpression.leftOperand=current} "/" | {DivExpression.leftOperand=current} "div" |
	//	{ModExpression.leftOperand=current} "mod") rightOperand=SignumExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	////prefix unary, right-associative
	////non-associative
	////{UnaryMinusExpression} => '-' expression=ValueAccessExpression | ValueAccessExpression
	//SignumExpression returns Expression:
	//	{UnaryMinusExpression} => "-" operand=SignumExpression | {UnaryPlusExpression} => "+" operand=SignumExpression |
	//	AccessExpression;
	public SignumExpressionElements getSignumExpressionAccess() {
		return pSignumExpression;
	}
	
	public ParserRule getSignumExpressionRule() {
		return getSignumExpressionAccess().getRule();
	}

	////binary (postfix unary), left-associative
	//AccessExpression returns Expression:
	//	PrimaryExpression ({ArrayAccessExpression.operand=current} "[" (parameters+=Expression ("," parameters+=Expression)*)
	//	"]" | {FunctionAccessExpression.operand=current} "(" (parameters+=Expression ("," parameters+=Expression)*) ")" |
	//	{RecordAccessExpression.operand=current} "." field=ID | {TupleAccessExpression.operand=current} "!" index=INTEGER |
	//	{PrimedExpression.operand=current} "\'")*;
	public AccessExpressionElements getAccessExpressionAccess() {
		return pAccessExpression;
	}
	
	public ParserRule getAccessExpressionRule() {
		return getAccessExpressionAccess().getRule();
	}

	//////postfix unary, non-associative
	////PrimedExpression returns Expression:
	////	PrimaryExpression ({PrimedExpression.operand=current} '^')?
	////	//left-associative
	////	//ValueAccessExpression ({PrimedExpression.expression=current} '^')*
	////;
	//PrimaryExpression returns Expression:
	//	LiteralExpression | ReferenceExpression | "(" Expression ")";
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//ReferenceExpression:
	//	declaration=[Declaration];
	public ReferenceExpressionElements getReferenceExpressionAccess() {
		return pReferenceExpression;
	}
	
	public ParserRule getReferenceExpressionRule() {
		return getReferenceExpressionAccess().getRule();
	}

	//LiteralExpression returns Expression:
	//	IntegerLiteralExpression | DecimalLiteralExpression | RationalLiteralExpression | BooleanLiteralExpression |
	//	ArrayLiteralExpression | RecordLiteralExpression | TupleLiteralExpression | EnumerationLiteralExpression;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//IntegerLiteralExpression:
	//	value=INTEGER;
	public IntegerLiteralExpressionElements getIntegerLiteralExpressionAccess() {
		return pIntegerLiteralExpression;
	}
	
	public ParserRule getIntegerLiteralExpressionRule() {
		return getIntegerLiteralExpressionAccess().getRule();
	}

	//DecimalLiteralExpression:
	//	value=DECIMAL;
	public DecimalLiteralExpressionElements getDecimalLiteralExpressionAccess() {
		return pDecimalLiteralExpression;
	}
	
	public ParserRule getDecimalLiteralExpressionRule() {
		return getDecimalLiteralExpressionAccess().getRule();
	}

	//RationalLiteralExpression:
	//	numerator=INTEGER "%" denominator=INTEGER;
	public RationalLiteralExpressionElements getRationalLiteralExpressionAccess() {
		return pRationalLiteralExpression;
	}
	
	public ParserRule getRationalLiteralExpressionRule() {
		return getRationalLiteralExpressionAccess().getRule();
	}

	//BooleanLiteralExpression:
	//	TrueExpression | FalseExpression;
	public BooleanLiteralExpressionElements getBooleanLiteralExpressionAccess() {
		return pBooleanLiteralExpression;
	}
	
	public ParserRule getBooleanLiteralExpressionRule() {
		return getBooleanLiteralExpressionAccess().getRule();
	}

	//TrueExpression:
	//	{TrueExpression} "true";
	public TrueExpressionElements getTrueExpressionAccess() {
		return pTrueExpression;
	}
	
	public ParserRule getTrueExpressionRule() {
		return getTrueExpressionAccess().getRule();
	}

	//FalseExpression:
	//	{FalseExpression} "false";
	public FalseExpressionElements getFalseExpressionAccess() {
		return pFalseExpression;
	}
	
	public ParserRule getFalseExpressionRule() {
		return getFalseExpressionAccess().getRule();
	}

	//ArrayLiteralExpression:
	//	"[" (parameterDeclarations+=ParameterDeclaration ("," parameterDeclarations+=ParameterDeclaration)*)? "|"
	//	operand=Expression "]";
	public ArrayLiteralExpressionElements getArrayLiteralExpressionAccess() {
		return pArrayLiteralExpression;
	}
	
	public ParserRule getArrayLiteralExpressionRule() {
		return getArrayLiteralExpressionAccess().getRule();
	}

	//RecordLiteralExpression:
	//	"(#" fieldAssignments+=FieldAssignment ("," fieldAssignments+=FieldAssignment)* "#)";
	public RecordLiteralExpressionElements getRecordLiteralExpressionAccess() {
		return pRecordLiteralExpression;
	}
	
	public ParserRule getRecordLiteralExpressionRule() {
		return getRecordLiteralExpressionAccess().getRule();
	}

	//FieldAssignment:
	//	reference=ID ":=" value=Expression;
	public FieldAssignmentElements getFieldAssignmentAccess() {
		return pFieldAssignment;
	}
	
	public ParserRule getFieldAssignmentRule() {
		return getFieldAssignmentAccess().getRule();
	}

	//TupleLiteralExpression:
	//	"(#" expressions+=Expression ("," expressions+=Expression)* "#)";
	public TupleLiteralExpressionElements getTupleLiteralExpressionAccess() {
		return pTupleLiteralExpression;
	}
	
	public ParserRule getTupleLiteralExpressionRule() {
		return getTupleLiteralExpressionAccess().getRule();
	}

	//EnumerationLiteralExpression:
	//	"::" reference=[EnumerationLiteralDefinition];
	public EnumerationLiteralExpressionElements getEnumerationLiteralExpressionAccess() {
		return pEnumerationLiteralExpression;
	}
	
	public ParserRule getEnumerationLiteralExpressionRule() {
		return getEnumerationLiteralExpressionAccess().getRule();
	}

	/////////////////////////////////
	//// Basic Constraint
	/////////////////////////////////
	//BasicConstraintDefinition:
	//	"constraint" expression=Expression;
	public BasicConstraintDefinitionElements getBasicConstraintDefinitionAccess() {
		return pBasicConstraintDefinition;
	}
	
	public ParserRule getBasicConstraintDefinitionRule() {
		return getBasicConstraintDefinitionAccess().getRule();
	}

	/////////////////////////////////
	//// Terminal
	/////////////////////////////////
	//terminal INT returns Ecore::EInt:
	//	"INT has been deactivated";
	public TerminalRule getINTRule() {
		return tINT;
	} 

	//terminal STRING:
	//	"STRING has been deactivated";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal INTEGER returns Ecore::EBigInteger:
	//	"-"? "0".."9"+;
	public TerminalRule getINTEGERRule() {
		return tINTEGER;
	} 

	//terminal DECIMAL returns Ecore::EBigDecimal:
	//	"-"? "0".."9"+ "." "0".."9"+;
	public TerminalRule getDECIMALRule() {
		return tDECIMAL;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
