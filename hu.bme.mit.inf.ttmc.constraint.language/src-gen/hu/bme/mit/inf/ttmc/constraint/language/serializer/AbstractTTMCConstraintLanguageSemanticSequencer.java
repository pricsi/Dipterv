/*
 * generated by Xtext
 */
package hu.bme.mit.inf.ttmc.constraint.language.serializer;

import TTMCConstraint.AddExpression;
import TTMCConstraint.AndExpression;
import TTMCConstraint.ArrayAccessExpression;
import TTMCConstraint.ArrayLiteralExpression;
import TTMCConstraint.ArrayTypeDefinition;
import TTMCConstraint.BasicConstraintDefinition;
import TTMCConstraint.BooleanTypeDefinition;
import TTMCConstraint.ConstantDeclaration;
import TTMCConstraint.ConstraintSpecification;
import TTMCConstraint.DecimalLiteralExpression;
import TTMCConstraint.DivExpression;
import TTMCConstraint.DivideExpression;
import TTMCConstraint.EnumerationLiteralDefinition;
import TTMCConstraint.EnumerationLiteralExpression;
import TTMCConstraint.EnumerationTypeDefinition;
import TTMCConstraint.EqualExpression;
import TTMCConstraint.EqualityExpression;
import TTMCConstraint.ExistsExpression;
import TTMCConstraint.FalseExpression;
import TTMCConstraint.FieldAssignment;
import TTMCConstraint.FieldDeclaration;
import TTMCConstraint.FinallyExpression;
import TTMCConstraint.ForallExpression;
import TTMCConstraint.FunctionAccessExpression;
import TTMCConstraint.FunctionDeclaration;
import TTMCConstraint.FunctionLiteralExpression;
import TTMCConstraint.FunctionTypeDefinition;
import TTMCConstraint.GloballyExpression;
import TTMCConstraint.GreaterEqualExpression;
import TTMCConstraint.GreaterExpression;
import TTMCConstraint.IfThenElseExpression;
import TTMCConstraint.ImplyExpression;
import TTMCConstraint.InExpression;
import TTMCConstraint.InequalityExpression;
import TTMCConstraint.IntegerLiteralExpression;
import TTMCConstraint.IntegerTypeDefinition;
import TTMCConstraint.LessEqualExpression;
import TTMCConstraint.LessExpression;
import TTMCConstraint.LetDeclaration;
import TTMCConstraint.LetExpression;
import TTMCConstraint.ModExpression;
import TTMCConstraint.MultiplyExpression;
import TTMCConstraint.NaturalTypeDefinition;
import TTMCConstraint.NextExpression;
import TTMCConstraint.NotExpression;
import TTMCConstraint.OrExpression;
import TTMCConstraint.ParameterDeclaration;
import TTMCConstraint.PrimedExpression;
import TTMCConstraint.RationalLiteralExpression;
import TTMCConstraint.RealTypeDefinition;
import TTMCConstraint.RecordAccessExpression;
import TTMCConstraint.RecordLiteralExpression;
import TTMCConstraint.RecordTypeDefinition;
import TTMCConstraint.ReferenceExpression;
import TTMCConstraint.ReleaseExpression;
import TTMCConstraint.SubTypeDefinition;
import TTMCConstraint.SubrangeTypeDefinition;
import TTMCConstraint.SubtractExpression;
import TTMCConstraint.TTMCConstraintPackage;
import TTMCConstraint.TemporalExistsExpression;
import TTMCConstraint.TemporalForallExpression;
import TTMCConstraint.TrueExpression;
import TTMCConstraint.TupleAccessExpression;
import TTMCConstraint.TupleLiteralExpression;
import TTMCConstraint.TupleTypeDefinition;
import TTMCConstraint.TypeDeclaration;
import TTMCConstraint.TypeReference;
import TTMCConstraint.UnaryMinusExpression;
import TTMCConstraint.UnaryPlusExpression;
import TTMCConstraint.UntilExpression;
import com.google.inject.Inject;
import com.google.inject.Provider;
import hu.bme.mit.inf.ttmc.constraint.language.services.TTMCConstraintLanguageGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractTTMCConstraintLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TTMCConstraintLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == TTMCConstraintPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TTMCConstraintPackage.ADD_EXPRESSION:
				sequence_AdditiveExpression(context, (AddExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (ArrayAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_LITERAL_EXPRESSION:
				sequence_ArrayLiteralExpression(context, (ArrayLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_TYPE_DEFINITION:
				sequence_ArrayTypeDefinition(context, (ArrayTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.BASIC_CONSTRAINT_DEFINITION:
				sequence_BasicConstraintDefinition(context, (BasicConstraintDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.BOOLEAN_TYPE_DEFINITION:
				sequence_BooleanTypeDefinition(context, (BooleanTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.CONSTANT_DECLARATION:
				sequence_ConstantDeclaration(context, (ConstantDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.CONSTRAINT_SPECIFICATION:
				sequence_ConstraintSpecification(context, (ConstraintSpecification) semanticObject); 
				return; 
			case TTMCConstraintPackage.DECIMAL_LITERAL_EXPRESSION:
				sequence_DecimalLiteralExpression(context, (DecimalLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.DIV_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.DIVIDE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivideExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_LITERAL_DEFINITION:
				sequence_EnumerationLiteralDefinition(context, (EnumerationLiteralDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_LITERAL_EXPRESSION:
				sequence_EnumerationLiteralExpression(context, (EnumerationLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_TYPE_DEFINITION:
				sequence_EnumerationTypeDefinition(context, (EnumerationTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.EQUAL_EXPRESSION:
				sequence_EqualExpression(context, (EqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.EQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.EXISTS_EXPRESSION:
				sequence_ExistsExpression(context, (ExistsExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FALSE_EXPRESSION:
				sequence_FalseExpression(context, (FalseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FIELD_ASSIGNMENT:
				sequence_FieldAssignment(context, (FieldAssignment) semanticObject); 
				return; 
			case TTMCConstraintPackage.FIELD_DECLARATION:
				sequence_FieldDeclaration(context, (FieldDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.FINALLY_EXPRESSION:
				sequence_FinallyExpression(context, (FinallyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FORALL_EXPRESSION:
				sequence_ForallExpression(context, (ForallExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (FunctionAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_LITERAL_EXPRESSION:
				sequence_FunctionLiteralExpression(context, (FunctionLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_TYPE_DEFINITION:
				sequence_FunctionTypeDefinition(context, (FunctionTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.GLOBALLY_EXPRESSION:
				sequence_GloballyExpression(context, (GloballyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.GREATER_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterEqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.GREATER_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IF_THEN_ELSE_EXPRESSION:
				sequence_IfThenElseExpression(context, (IfThenElseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IMPLY_EXPRESSION:
				sequence_ImplyExpression(context, (ImplyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IN_EXPRESSION:
				sequence_InExpression(context, (InExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INEQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (InequalityExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INTEGER_LITERAL_EXPRESSION:
				sequence_IntegerLiteralExpression(context, (IntegerLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INTEGER_TYPE_DEFINITION:
				sequence_IntegerTypeDefinition(context, (IntegerTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.LESS_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (LessEqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.LESS_EXPRESSION:
				sequence_ComparisionExpression(context, (LessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.LET_DECLARATION:
				sequence_LetDeclaration(context, (LetDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.MOD_EXPRESSION:
				sequence_MultiplicativeExpression(context, (ModExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.MULTIPLY_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.NATURAL_TYPE_DEFINITION:
				sequence_NaturalTypeDefinition(context, (NaturalTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.NEXT_EXPRESSION:
				sequence_NextExpression(context, (NextExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.PRIMED_EXPRESSION:
				sequence_AccessExpression(context, (PrimedExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RATIONAL_LITERAL_EXPRESSION:
				sequence_RationalLiteralExpression(context, (RationalLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.REAL_TYPE_DEFINITION:
				sequence_RealTypeDefinition(context, (RealTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (RecordAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_LITERAL_EXPRESSION:
				sequence_RecordLiteralExpression(context, (RecordLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_TYPE_DEFINITION:
				sequence_RecordTypeDefinition(context, (RecordTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.REFERENCE_EXPRESSION:
				sequence_ReferenceExpression(context, (ReferenceExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RELEASE_EXPRESSION:
				sequence_ReleaseExpression(context, (ReleaseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUB_TYPE_DEFINITION:
				sequence_SubTypeDefinition(context, (SubTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUBRANGE_TYPE_DEFINITION:
				sequence_SubrangeTypeDefinition(context, (SubrangeTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUBTRACT_EXPRESSION:
				sequence_AdditiveExpression(context, (SubtractExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TEMPORAL_EXISTS_EXPRESSION:
				sequence_TemporalExistsExpression(context, (TemporalExistsExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TEMPORAL_FORALL_EXPRESSION:
				sequence_TemporalForallExpression(context, (TemporalForallExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TRUE_EXPRESSION:
				sequence_TrueExpression(context, (TrueExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (TupleAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_LITERAL_EXPRESSION:
				sequence_TupleLiteralExpression(context, (TupleLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_TYPE_DEFINITION:
				sequence_TupleTypeDefinition(context, (TupleTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNARY_MINUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryMinusExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNARY_PLUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryPlusExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNTIL_EXPRESSION:
				sequence_UntilExpression(context, (UntilExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (operand=AccessExpression_ArrayAccessExpression_1_0_0 (parameters+=Expression parameters+=Expression*))
	 */
	protected void sequence_AccessExpression(EObject context, ArrayAccessExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operand=AccessExpression_FunctionAccessExpression_1_1_0 (parameters+=Expression parameters+=Expression*))
	 */
	protected void sequence_AccessExpression(EObject context, FunctionAccessExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     operand=AccessExpression_PrimedExpression_1_4_0
	 */
	protected void sequence_AccessExpression(EObject context, PrimedExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAccessExpressionAccess().getPrimedExpressionOperandAction_1_4_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operand=AccessExpression_RecordAccessExpression_1_2_0 field=ID)
	 */
	protected void sequence_AccessExpression(EObject context, RecordAccessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.ACCESS_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.ACCESS_EXPRESSION__OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.RECORD_ACCESS_EXPRESSION__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.RECORD_ACCESS_EXPRESSION__FIELD));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAccessExpressionAccess().getRecordAccessExpressionOperandAction_1_2_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getAccessExpressionAccess().getFieldIDTerminalRuleCall_1_2_2_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operand=AccessExpression_TupleAccessExpression_1_3_0 index=INTEGER)
	 */
	protected void sequence_AccessExpression(EObject context, TupleAccessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.ACCESS_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.ACCESS_EXPRESSION__OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.TUPLE_ACCESS_EXPRESSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.TUPLE_ACCESS_EXPRESSION__INDEX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAccessExpressionAccess().getTupleAccessExpressionOperandAction_1_3_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getAccessExpressionAccess().getIndexINTEGERTerminalRuleCall_1_3_2_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operands+=AdditiveExpression_AddExpression_1_0_0 operands+=MultiplicativeExpression+)
	 */
	protected void sequence_AdditiveExpression(EObject context, AddExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=AdditiveExpression_SubtractExpression_1_1_0 rightOperand=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpression(EObject context, SubtractExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getSubtractExpressionLeftOperandAction_1_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getRightOperandMultiplicativeExpressionParserRuleCall_1_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operands+=AndExpression_AndExpression_1_0 operands+=ReleaseExpression+)
	 */
	protected void sequence_AndExpression(EObject context, AndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? operand=Expression)
	 */
	protected void sequence_ArrayLiteralExpression(EObject context, ArrayLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (indexTypes+=Type indexTypes+=Type* elementType=Type)
	 */
	protected void sequence_ArrayTypeDefinition(EObject context, ArrayTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_BasicConstraintDefinition(EObject context, BasicConstraintDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBasicConstraintDefinitionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {BooleanTypeDefinition}
	 */
	protected void sequence_BooleanTypeDefinition(EObject context, BooleanTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=ComparisionExpression_GreaterEqualExpression_1_0_1_0 rightOperand=AdditiveExpression)
	 */
	protected void sequence_ComparisionExpression(EObject context, GreaterEqualExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getGreaterEqualExpressionLeftOperandAction_1_0_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getRightOperandAdditiveExpressionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=ComparisionExpression_GreaterExpression_1_0_0_0 rightOperand=AdditiveExpression)
	 */
	protected void sequence_ComparisionExpression(EObject context, GreaterExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getGreaterExpressionLeftOperandAction_1_0_0_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getRightOperandAdditiveExpressionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=ComparisionExpression_LessEqualExpression_1_0_3_0 rightOperand=AdditiveExpression)
	 */
	protected void sequence_ComparisionExpression(EObject context, LessEqualExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getLessEqualExpressionLeftOperandAction_1_0_3_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getRightOperandAdditiveExpressionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=ComparisionExpression_LessExpression_1_0_2_0 rightOperand=AdditiveExpression)
	 */
	protected void sequence_ComparisionExpression(EObject context, LessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getLessExpressionLeftOperandAction_1_0_2_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getComparisionExpressionAccess().getRightOperandAdditiveExpressionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type expression=Expression?)
	 */
	protected void sequence_ConstantDeclaration(EObject context, ConstantDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         (
	 *             typeDeclarations+=TypeDeclaration | 
	 *             constantDeclarations+=ConstantDeclaration | 
	 *             functionDeclarations+=FunctionDeclaration | 
	 *             basicConstraintDefinitions+=BasicConstraintDefinition
	 *         )*
	 *     )
	 */
	protected void sequence_ConstraintSpecification(EObject context, ConstraintSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_DecimalLiteralExpression(EObject context, DecimalLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECIMAL_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECIMAL_LITERAL_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDecimalLiteralExpressionAccess().getValueDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumerationLiteralDefinition(EObject context, EnumerationLiteralDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEnumerationLiteralDefinitionAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     reference=[EnumerationLiteralDefinition|ID]
	 */
	protected void sequence_EnumerationLiteralExpression(EObject context, EnumerationLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.ENUMERATION_LITERAL_EXPRESSION__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.ENUMERATION_LITERAL_EXPRESSION__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEnumerationLiteralExpressionAccess().getReferenceEnumerationLiteralDefinitionIDTerminalRuleCall_1_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (literals+=EnumerationLiteralDefinition literals+=EnumerationLiteralDefinition*)
	 */
	protected void sequence_EnumerationTypeDefinition(EObject context, EnumerationTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=EqualExpression_EqualExpression_1_0 rightOperand=EqualExpression)
	 */
	protected void sequence_EqualExpression(EObject context, EqualExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEqualExpressionAccess().getEqualExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getEqualExpressionAccess().getRightOperandEqualExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=EquivalenceExpression_EqualityExpression_1_0_0 rightOperand=ComparisionExpression)
	 */
	protected void sequence_EquivalenceExpression(EObject context, EqualityExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEquivalenceExpressionAccess().getEqualityExpressionLeftOperandAction_1_0_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getEquivalenceExpressionAccess().getRightOperandComparisionExpressionParserRuleCall_1_0_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=EquivalenceExpression_InequalityExpression_1_1_0 rightOperand=ComparisionExpression)
	 */
	protected void sequence_EquivalenceExpression(EObject context, InequalityExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEquivalenceExpressionAccess().getInequalityExpressionLeftOperandAction_1_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getEquivalenceExpressionAccess().getRightOperandComparisionExpressionParserRuleCall_1_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? operand=UnaryLogicExpression)
	 */
	protected void sequence_ExistsExpression(EObject context, ExistsExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {FalseExpression}
	 */
	protected void sequence_FalseExpression(EObject context, FalseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (reference=ID value=Expression)
	 */
	protected void sequence_FieldAssignment(EObject context, FieldAssignment semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.FIELD_ASSIGNMENT__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.FIELD_ASSIGNMENT__REFERENCE));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.FIELD_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.FIELD_ASSIGNMENT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFieldAssignmentAccess().getReferenceIDTerminalRuleCall_0_0(), semanticObject.getReference());
		feeder.accept(grammarAccess.getFieldAssignmentAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_FieldDeclaration(EObject context, FieldDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFieldDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=UnaryLogicExpression
	 */
	protected void sequence_FinallyExpression(EObject context, FinallyExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFinallyExpressionAccess().getOperandUnaryLogicExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? operand=UnaryLogicExpression)
	 */
	protected void sequence_ForallExpression(EObject context, ForallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? type=Type expression=Expression?)
	 */
	protected void sequence_FunctionDeclaration(EObject context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? returnType=Type operand=UnaryLogicExpression)
	 */
	protected void sequence_FunctionLiteralExpression(EObject context, FunctionLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((parameterTypes+=Type parameterTypes+=Type*)? returnType=Type)
	 */
	protected void sequence_FunctionTypeDefinition(EObject context, FunctionTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     operand=UnaryLogicExpression
	 */
	protected void sequence_GloballyExpression(EObject context, GloballyExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGloballyExpressionAccess().getOperandUnaryLogicExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expression then=Expression else=Expression)
	 */
	protected void sequence_IfThenElseExpression(EObject context, IfThenElseExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.IF_THEN_ELSE_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.IF_THEN_ELSE_EXPRESSION__CONDITION));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.IF_THEN_ELSE_EXPRESSION__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.IF_THEN_ELSE_EXPRESSION__THEN));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.IF_THEN_ELSE_EXPRESSION__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.IF_THEN_ELSE_EXPRESSION__ELSE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIfThenElseExpressionAccess().getConditionExpressionParserRuleCall_0_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfThenElseExpressionAccess().getThenExpressionParserRuleCall_0_4_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getIfThenElseExpressionAccess().getElseExpressionParserRuleCall_0_5_1_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=ImplyExpression_ImplyExpression_1_0 rightOperand=ImplyExpression)
	 */
	protected void sequence_ImplyExpression(EObject context, ImplyExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImplyExpressionAccess().getImplyExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getImplyExpressionAccess().getRightOperandImplyExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operand=InExpression_InExpression_1_0 type=Type)
	 */
	protected void sequence_InExpression(EObject context, InExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.IN_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.IN_EXPRESSION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInExpressionAccess().getInExpressionOperandAction_1_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getInExpressionAccess().getTypeTypeParserRuleCall_1_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INTEGER
	 */
	protected void sequence_IntegerLiteralExpression(EObject context, IntegerLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.INTEGER_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.INTEGER_LITERAL_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerLiteralExpressionAccess().getValueINTEGERTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {IntegerTypeDefinition}
	 */
	protected void sequence_IntegerTypeDefinition(EObject context, IntegerTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type expression=Expression)
	 */
	protected void sequence_LetDeclaration(EObject context, LetDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DEFINABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DEFINABLE_DECLARATION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLetDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLetDeclarationAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (letDeclarations+=LetDeclaration letDeclarations+=LetDeclaration* expression=UnaryLogicExpression)
	 */
	protected void sequence_LetExpression(EObject context, LetExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=MultiplicativeExpression_DivExpression_1_1_0_1_0 rightOperand=SignumExpression)
	 */
	protected void sequence_MultiplicativeExpression(EObject context, DivExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getDivExpressionLeftOperandAction_1_1_0_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightOperandSignumExpressionParserRuleCall_1_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=MultiplicativeExpression_DivideExpression_1_1_0_0_0 rightOperand=SignumExpression)
	 */
	protected void sequence_MultiplicativeExpression(EObject context, DivideExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getDivideExpressionLeftOperandAction_1_1_0_0_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightOperandSignumExpressionParserRuleCall_1_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=MultiplicativeExpression_ModExpression_1_1_0_2_0 rightOperand=SignumExpression)
	 */
	protected void sequence_MultiplicativeExpression(EObject context, ModExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getModExpressionLeftOperandAction_1_1_0_2_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightOperandSignumExpressionParserRuleCall_1_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operands+=MultiplicativeExpression_MultiplyExpression_1_0_0 operands+=SignumExpression+)
	 */
	protected void sequence_MultiplicativeExpression(EObject context, MultiplyExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {NaturalTypeDefinition}
	 */
	protected void sequence_NaturalTypeDefinition(EObject context, NaturalTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     operand=UnaryLogicExpression
	 */
	protected void sequence_NextExpression(EObject context, NextExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNextExpressionAccess().getOperandUnaryLogicExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=UnaryLogicExpression
	 */
	protected void sequence_NotExpression(EObject context, NotExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNotExpressionAccess().getOperandUnaryLogicExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operands+=OrExpression_OrExpression_1_0 operands+=AndExpression+)
	 */
	protected void sequence_OrExpression(EObject context, OrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_ParameterDeclaration(EObject context, ParameterDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (numerator=INTEGER denominator=INTEGER)
	 */
	protected void sequence_RationalLiteralExpression(EObject context, RationalLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.RATIONAL_LITERAL_EXPRESSION__NUMERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.RATIONAL_LITERAL_EXPRESSION__NUMERATOR));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.RATIONAL_LITERAL_EXPRESSION__DENOMINATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.RATIONAL_LITERAL_EXPRESSION__DENOMINATOR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRationalLiteralExpressionAccess().getNumeratorINTEGERTerminalRuleCall_0_0(), semanticObject.getNumerator());
		feeder.accept(grammarAccess.getRationalLiteralExpressionAccess().getDenominatorINTEGERTerminalRuleCall_2_0(), semanticObject.getDenominator());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {RealTypeDefinition}
	 */
	protected void sequence_RealTypeDefinition(EObject context, RealTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fieldAssignments+=FieldAssignment fieldAssignments+=FieldAssignment*)
	 */
	protected void sequence_RecordLiteralExpression(EObject context, RecordLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fieldDeclarations+=FieldDeclaration fieldDeclarations+=FieldDeclaration*)
	 */
	protected void sequence_RecordTypeDefinition(EObject context, RecordTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     declaration=[Declaration|ID]
	 */
	protected void sequence_ReferenceExpression(EObject context, ReferenceExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.REFERENCE_EXPRESSION__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.REFERENCE_EXPRESSION__DECLARATION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReferenceExpressionAccess().getDeclarationDeclarationIDTerminalRuleCall_0_1(), semanticObject.getDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=ReleaseExpression_ReleaseExpression_1_0 rightOperand=UntilExpression)
	 */
	protected void sequence_ReleaseExpression(EObject context, ReleaseExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReleaseExpressionAccess().getReleaseExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getReleaseExpressionAccess().getRightOperandUntilExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=SignumExpression
	 */
	protected void sequence_SignumExpression(EObject context, UnaryMinusExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSignumExpressionAccess().getOperandSignumExpressionParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=SignumExpression
	 */
	protected void sequence_SignumExpression(EObject context, UnaryPlusExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSignumExpressionAccess().getOperandSignumExpressionParserRuleCall_1_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (parameterDeclaration=ParameterDeclaration expression=Expression)
	 */
	protected void sequence_SubTypeDefinition(EObject context, SubTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (lowerBound=Expression? upperBound=Expression?)
	 */
	protected void sequence_SubrangeTypeDefinition(EObject context, SubrangeTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     operand=UnaryLogicExpression
	 */
	protected void sequence_TemporalExistsExpression(EObject context, TemporalExistsExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTemporalExistsExpressionAccess().getOperandUnaryLogicExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=UnaryLogicExpression
	 */
	protected void sequence_TemporalForallExpression(EObject context, TemporalForallExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTemporalForallExpressionAccess().getOperandUnaryLogicExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {TrueExpression}
	 */
	protected void sequence_TrueExpression(EObject context, TrueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)
	 */
	protected void sequence_TupleLiteralExpression(EObject context, TupleLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (types+=Type types+=Type*)
	 */
	protected void sequence_TupleTypeDefinition(EObject context, TupleTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_TypeDeclaration(EObject context, TypeDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.TYPE_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.TYPE_DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     reference=[TypeDeclaration|ID]
	 */
	protected void sequence_TypeReference(EObject context, TypeReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.TYPE_REFERENCE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.TYPE_REFERENCE__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypeReferenceAccess().getReferenceTypeDeclarationIDTerminalRuleCall_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=UntilExpression_UntilExpression_1_0 rightOperand=UnaryLogicExpression)
	 */
	protected void sequence_UntilExpression(EObject context, UntilExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__LEFT_OPERAND));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.BINARY_EXPRESSION__RIGHT_OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getUntilExpressionAccess().getUntilExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getUntilExpressionAccess().getRightOperandUnaryLogicExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
}
