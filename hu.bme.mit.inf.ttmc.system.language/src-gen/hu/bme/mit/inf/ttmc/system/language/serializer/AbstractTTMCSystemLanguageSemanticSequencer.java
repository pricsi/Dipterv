/*
 * generated by Xtext
 */
package hu.bme.mit.inf.ttmc.system.language.serializer;

import TTMCConstraint.AddExpression;
import TTMCConstraint.AndExpression;
import TTMCConstraint.ArrayAccessExpression;
import TTMCConstraint.ArrayLiteralExpression;
import TTMCConstraint.ArrayTypeDefinition;
import TTMCConstraint.BasicConstraintDefinition;
import TTMCConstraint.BooleanTypeDefinition;
import TTMCConstraint.ConstantDeclaration;
import TTMCConstraint.ConstraintSpecification;
import TTMCConstraint.DecimalLiteralExpression;
import TTMCConstraint.DivExpression;
import TTMCConstraint.DivideExpression;
import TTMCConstraint.EnumerationLiteralDefinition;
import TTMCConstraint.EnumerationLiteralExpression;
import TTMCConstraint.EnumerationTypeDefinition;
import TTMCConstraint.EqualExpression;
import TTMCConstraint.EqualityExpression;
import TTMCConstraint.ExistsExpression;
import TTMCConstraint.FalseExpression;
import TTMCConstraint.FieldAssignment;
import TTMCConstraint.FieldDeclaration;
import TTMCConstraint.FinallyExpression;
import TTMCConstraint.ForallExpression;
import TTMCConstraint.FunctionAccessExpression;
import TTMCConstraint.FunctionDeclaration;
import TTMCConstraint.FunctionLiteralExpression;
import TTMCConstraint.FunctionTypeDefinition;
import TTMCConstraint.GloballyExpression;
import TTMCConstraint.GreaterEqualExpression;
import TTMCConstraint.GreaterExpression;
import TTMCConstraint.IfThenElseExpression;
import TTMCConstraint.ImplyExpression;
import TTMCConstraint.InExpression;
import TTMCConstraint.InequalityExpression;
import TTMCConstraint.IntegerLiteralExpression;
import TTMCConstraint.IntegerTypeDefinition;
import TTMCConstraint.LessEqualExpression;
import TTMCConstraint.LessExpression;
import TTMCConstraint.LetDeclaration;
import TTMCConstraint.LetExpression;
import TTMCConstraint.ModExpression;
import TTMCConstraint.MultiplyExpression;
import TTMCConstraint.NaturalTypeDefinition;
import TTMCConstraint.NextExpression;
import TTMCConstraint.NotExpression;
import TTMCConstraint.OrExpression;
import TTMCConstraint.ParameterDeclaration;
import TTMCConstraint.PrimedExpression;
import TTMCConstraint.RationalLiteralExpression;
import TTMCConstraint.RealTypeDefinition;
import TTMCConstraint.RecordAccessExpression;
import TTMCConstraint.RecordLiteralExpression;
import TTMCConstraint.RecordTypeDefinition;
import TTMCConstraint.ReferenceExpression;
import TTMCConstraint.ReleaseExpression;
import TTMCConstraint.SubTypeDefinition;
import TTMCConstraint.SubrangeTypeDefinition;
import TTMCConstraint.SubtractExpression;
import TTMCConstraint.TTMCConstraintPackage;
import TTMCConstraint.TemporalExistsExpression;
import TTMCConstraint.TemporalForallExpression;
import TTMCConstraint.TrueExpression;
import TTMCConstraint.TupleAccessExpression;
import TTMCConstraint.TupleLiteralExpression;
import TTMCConstraint.TupleTypeDefinition;
import TTMCConstraint.TypeDeclaration;
import TTMCConstraint.TypeReference;
import TTMCConstraint.UnaryMinusExpression;
import TTMCConstraint.UnaryPlusExpression;
import TTMCConstraint.UntilExpression;
import TTMCSystem.AsynchronousCompositeSystem;
import TTMCSystem.AsynchronousMultiSystem;
import TTMCSystem.DefinitionDeclaration;
import TTMCSystem.GlobalVariableDeclaration;
import TTMCSystem.InitialConstraintDefinition;
import TTMCSystem.InputVariableDeclaration;
import TTMCSystem.InvariantConstraintDefinition;
import TTMCSystem.LocalVariableDeclaration;
import TTMCSystem.OutputVariableDeclaration;
import TTMCSystem.PropertyDeclaration;
import TTMCSystem.SynchronousCompositeSystem;
import TTMCSystem.SynchronousMultiSystem;
import TTMCSystem.SystemDeclaration;
import TTMCSystem.SystemDefinition;
import TTMCSystem.SystemReference;
import TTMCSystem.SystemSpecification;
import TTMCSystem.TTMCSystemPackage;
import TTMCSystem.TransitionConstraintDefinition;
import com.google.inject.Inject;
import com.google.inject.Provider;
import hu.bme.mit.inf.ttmc.constraint.language.serializer.TTMCConstraintLanguageSemanticSequencer;
import hu.bme.mit.inf.ttmc.system.language.services.TTMCSystemLanguageGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractTTMCSystemLanguageSemanticSequencer extends TTMCConstraintLanguageSemanticSequencer {

	@Inject
	private TTMCSystemLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == TTMCConstraintPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TTMCConstraintPackage.ADD_EXPRESSION:
				sequence_AdditiveExpression(context, (AddExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (ArrayAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_LITERAL_EXPRESSION:
				sequence_ArrayLiteralExpression(context, (ArrayLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_TYPE_DEFINITION:
				sequence_ArrayTypeDefinition(context, (ArrayTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.BASIC_CONSTRAINT_DEFINITION:
				sequence_BasicConstraintDefinition(context, (BasicConstraintDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.BOOLEAN_TYPE_DEFINITION:
				sequence_BooleanTypeDefinition(context, (BooleanTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.CONSTANT_DECLARATION:
				sequence_ConstantDeclaration(context, (ConstantDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.CONSTRAINT_SPECIFICATION:
				sequence_ConstraintSpecification(context, (ConstraintSpecification) semanticObject); 
				return; 
			case TTMCConstraintPackage.DECIMAL_LITERAL_EXPRESSION:
				sequence_DecimalLiteralExpression(context, (DecimalLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.DIV_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.DIVIDE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivideExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_LITERAL_DEFINITION:
				sequence_EnumerationLiteralDefinition(context, (EnumerationLiteralDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_LITERAL_EXPRESSION:
				sequence_EnumerationLiteralExpression(context, (EnumerationLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_TYPE_DEFINITION:
				sequence_EnumerationTypeDefinition(context, (EnumerationTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.EQUAL_EXPRESSION:
				sequence_EqualExpression(context, (EqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.EQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.EXISTS_EXPRESSION:
				sequence_ExistsExpression(context, (ExistsExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FALSE_EXPRESSION:
				sequence_FalseExpression(context, (FalseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FIELD_ASSIGNMENT:
				sequence_FieldAssignment(context, (FieldAssignment) semanticObject); 
				return; 
			case TTMCConstraintPackage.FIELD_DECLARATION:
				sequence_FieldDeclaration(context, (FieldDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.FINALLY_EXPRESSION:
				sequence_FinallyExpression(context, (FinallyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FORALL_EXPRESSION:
				sequence_ForallExpression(context, (ForallExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (FunctionAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_LITERAL_EXPRESSION:
				sequence_FunctionLiteralExpression(context, (FunctionLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_TYPE_DEFINITION:
				sequence_FunctionTypeDefinition(context, (FunctionTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.GLOBALLY_EXPRESSION:
				sequence_GloballyExpression(context, (GloballyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.GREATER_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterEqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.GREATER_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IF_THEN_ELSE_EXPRESSION:
				sequence_IfThenElseExpression(context, (IfThenElseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IMPLY_EXPRESSION:
				sequence_ImplyExpression(context, (ImplyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IN_EXPRESSION:
				sequence_InExpression(context, (InExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INEQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (InequalityExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INTEGER_LITERAL_EXPRESSION:
				sequence_IntegerLiteralExpression(context, (IntegerLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INTEGER_TYPE_DEFINITION:
				sequence_IntegerTypeDefinition(context, (IntegerTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.LESS_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (LessEqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.LESS_EXPRESSION:
				sequence_ComparisionExpression(context, (LessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.LET_DECLARATION:
				sequence_LetDeclaration(context, (LetDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.MOD_EXPRESSION:
				sequence_MultiplicativeExpression(context, (ModExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.MULTIPLY_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.NATURAL_TYPE_DEFINITION:
				sequence_NaturalTypeDefinition(context, (NaturalTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.NEXT_EXPRESSION:
				sequence_NextExpression(context, (NextExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.PRIMED_EXPRESSION:
				sequence_AccessExpression(context, (PrimedExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RATIONAL_LITERAL_EXPRESSION:
				sequence_RationalLiteralExpression(context, (RationalLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.REAL_TYPE_DEFINITION:
				sequence_RealTypeDefinition(context, (RealTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (RecordAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_LITERAL_EXPRESSION:
				sequence_RecordLiteralExpression(context, (RecordLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_TYPE_DEFINITION:
				sequence_RecordTypeDefinition(context, (RecordTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.REFERENCE_EXPRESSION:
				sequence_ReferenceExpression(context, (ReferenceExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RELEASE_EXPRESSION:
				sequence_ReleaseExpression(context, (ReleaseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUB_TYPE_DEFINITION:
				sequence_SubTypeDefinition(context, (SubTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUBRANGE_TYPE_DEFINITION:
				sequence_SubrangeTypeDefinition(context, (SubrangeTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUBTRACT_EXPRESSION:
				sequence_AdditiveExpression(context, (SubtractExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TEMPORAL_EXISTS_EXPRESSION:
				sequence_TemporalExistsExpression(context, (TemporalExistsExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TEMPORAL_FORALL_EXPRESSION:
				sequence_TemporalForallExpression(context, (TemporalForallExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TRUE_EXPRESSION:
				sequence_TrueExpression(context, (TrueExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (TupleAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_LITERAL_EXPRESSION:
				sequence_TupleLiteralExpression(context, (TupleLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_TYPE_DEFINITION:
				sequence_TupleTypeDefinition(context, (TupleTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNARY_MINUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryMinusExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNARY_PLUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryPlusExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNTIL_EXPRESSION:
				sequence_UntilExpression(context, (UntilExpression) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == TTMCSystemPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TTMCSystemPackage.ASYNCHRONOUS_COMPOSITE_SYSTEM:
				sequence_AsynchronousCompositeSystem(context, (AsynchronousCompositeSystem) semanticObject); 
				return; 
			case TTMCSystemPackage.ASYNCHRONOUS_MULTI_SYSTEM:
				sequence_AsynchronousMultiSystem(context, (AsynchronousMultiSystem) semanticObject); 
				return; 
			case TTMCSystemPackage.DEFINITION_DECLARATION:
				sequence_DefinitionDeclaration(context, (DefinitionDeclaration) semanticObject); 
				return; 
			case TTMCSystemPackage.GLOBAL_VARIABLE_DECLARATION:
				sequence_GlobalVariableDeclaration(context, (GlobalVariableDeclaration) semanticObject); 
				return; 
			case TTMCSystemPackage.INITIAL_CONSTRAINT_DEFINITION:
				sequence_InitialConstraintDefinition(context, (InitialConstraintDefinition) semanticObject); 
				return; 
			case TTMCSystemPackage.INPUT_VARIABLE_DECLARATION:
				sequence_InputVariableDeclaration(context, (InputVariableDeclaration) semanticObject); 
				return; 
			case TTMCSystemPackage.INVARIANT_CONSTRAINT_DEFINITION:
				sequence_InvariantConstraintDefinition(context, (InvariantConstraintDefinition) semanticObject); 
				return; 
			case TTMCSystemPackage.LOCAL_VARIABLE_DECLARATION:
				sequence_LocalVariableDeclaration(context, (LocalVariableDeclaration) semanticObject); 
				return; 
			case TTMCSystemPackage.OUTPUT_VARIABLE_DECLARATION:
				sequence_OutputVariableDeclaration(context, (OutputVariableDeclaration) semanticObject); 
				return; 
			case TTMCSystemPackage.PROPERTY_DECLARATION:
				sequence_PropertyDeclaration(context, (PropertyDeclaration) semanticObject); 
				return; 
			case TTMCSystemPackage.SYNCHRONOUS_COMPOSITE_SYSTEM:
				sequence_SynchronousCompositeSystem(context, (SynchronousCompositeSystem) semanticObject); 
				return; 
			case TTMCSystemPackage.SYNCHRONOUS_MULTI_SYSTEM:
				sequence_SynchronousMultiSystem(context, (SynchronousMultiSystem) semanticObject); 
				return; 
			case TTMCSystemPackage.SYSTEM_DECLARATION:
				sequence_SystemDeclaration(context, (SystemDeclaration) semanticObject); 
				return; 
			case TTMCSystemPackage.SYSTEM_DEFINITION:
				sequence_SystemDefinition(context, (SystemDefinition) semanticObject); 
				return; 
			case TTMCSystemPackage.SYSTEM_REFERENCE:
				sequence_SystemReference(context, (SystemReference) semanticObject); 
				return; 
			case TTMCSystemPackage.SYSTEM_SPECIFICATION:
				sequence_SystemSpecification(context, (SystemSpecification) semanticObject); 
				return; 
			case TTMCSystemPackage.TRANSITION_CONSTRAINT_DEFINITION:
				sequence_TransitionConstraintDefinition(context, (TransitionConstraintDefinition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (leftSystem=AsynchronousCompositeSystem_AsynchronousCompositeSystem_1_0 rightSystem=SynchronousCompositeSystem)
	 */
	protected void sequence_AsynchronousCompositeSystem(EObject context, AsynchronousCompositeSystem semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__LEFT_SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__LEFT_SYSTEM));
			if(transientValues.isValueTransient(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__RIGHT_SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__RIGHT_SYSTEM));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAsynchronousCompositeSystemAccess().getAsynchronousCompositeSystemLeftSystemAction_1_0(), semanticObject.getLeftSystem());
		feeder.accept(grammarAccess.getAsynchronousCompositeSystemAccess().getRightSystemSynchronousCompositeSystemParserRuleCall_1_2_0(), semanticObject.getRightSystem());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration* system=MultiSystem)
	 */
	protected void sequence_AsynchronousMultiSystem(EObject context, AsynchronousMultiSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type expression=Expression)
	 */
	protected void sequence_DefinitionDeclaration(EObject context, DefinitionDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DEFINABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DEFINABLE_DECLARATION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDefinitionDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefinitionDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDefinitionDeclarationAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_GlobalVariableDeclaration(EObject context, GlobalVariableDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGlobalVariableDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGlobalVariableDeclarationAccess().getTypeTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_InitialConstraintDefinition(EObject context, InitialConstraintDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInitialConstraintDefinitionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_InputVariableDeclaration(EObject context, InputVariableDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInputVariableDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInputVariableDeclarationAccess().getTypeTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_InvariantConstraintDefinition(EObject context, InvariantConstraintDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvariantConstraintDefinitionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_LocalVariableDeclaration(EObject context, LocalVariableDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLocalVariableDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalVariableDeclarationAccess().getTypeTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_OutputVariableDeclaration(EObject context, OutputVariableDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOutputVariableDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOutputVariableDeclarationAccess().getTypeTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID system=System expression=Expression)
	 */
	protected void sequence_PropertyDeclaration(EObject context, PropertyDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCSystemPackage.Literals.PROPERTY_DECLARATION__SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCSystemPackage.Literals.PROPERTY_DECLARATION__SYSTEM));
			if(transientValues.isValueTransient(semanticObject, TTMCSystemPackage.Literals.PROPERTY_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCSystemPackage.Literals.PROPERTY_DECLARATION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPropertyDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyDeclarationAccess().getSystemSystemParserRuleCall_3_0(), semanticObject.getSystem());
		feeder.accept(grammarAccess.getPropertyDeclarationAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftSystem=SynchronousCompositeSystem_SynchronousCompositeSystem_1_0 rightSystem=MultiSystem)
	 */
	protected void sequence_SynchronousCompositeSystem(EObject context, SynchronousCompositeSystem semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__LEFT_SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__LEFT_SYSTEM));
			if(transientValues.isValueTransient(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__RIGHT_SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCSystemPackage.Literals.COMPOSITE_SYSTEM__RIGHT_SYSTEM));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSynchronousCompositeSystemAccess().getSynchronousCompositeSystemLeftSystemAction_1_0(), semanticObject.getLeftSystem());
		feeder.accept(grammarAccess.getSynchronousCompositeSystemAccess().getRightSystemMultiSystemParserRuleCall_1_2_0(), semanticObject.getRightSystem());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration* system=MultiSystem)
	 */
	protected void sequence_SynchronousMultiSystem(EObject context, SynchronousMultiSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? system=System)
	 */
	protected void sequence_SystemDeclaration(EObject context, SystemDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             variableDeclarations+=VariableDeclaration | 
	 *             definitionDeclarations+=DefinitionDeclaration | 
	 *             systemConstraintDefinitions+=SystemConstraintDefinition
	 *         )*
	 *     )
	 */
	protected void sequence_SystemDefinition(EObject context, SystemDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (reference=[SystemDeclaration|ID] (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_SystemReference(EObject context, SystemReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         (
	 *             typeDeclarations+=TypeDeclaration | 
	 *             functionDeclarations+=FunctionDeclaration | 
	 *             constantDeclarations+=ConstantDeclaration | 
	 *             basicConstraintDefinitions+=BasicConstraintDefinition | 
	 *             systemDeclarations+=SystemDeclaration | 
	 *             propertyDeclarations+=PropertyDeclaration
	 *         )*
	 *     )
	 */
	protected void sequence_SystemSpecification(EObject context, SystemSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_TransitionConstraintDefinition(EObject context, TransitionConstraintDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.CONSTRAINT_DEFINITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTransitionConstraintDefinitionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
}
