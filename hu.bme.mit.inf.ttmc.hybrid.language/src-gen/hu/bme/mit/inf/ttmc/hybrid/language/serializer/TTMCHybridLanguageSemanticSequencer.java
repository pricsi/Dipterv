/*
 * generated by Xtext
 */
package hu.bme.mit.inf.ttmc.hybrid.language.serializer;

import TTMCConstraint.AddExpression;
import TTMCConstraint.AndExpression;
import TTMCConstraint.ArrayAccessExpression;
import TTMCConstraint.ArrayLiteralExpression;
import TTMCConstraint.ArrayTypeDefinition;
import TTMCConstraint.BasicConstraintDefinition;
import TTMCConstraint.BooleanTypeDefinition;
import TTMCConstraint.ConstantDeclaration;
import TTMCConstraint.ConstraintSpecification;
import TTMCConstraint.DecimalLiteralExpression;
import TTMCConstraint.DivExpression;
import TTMCConstraint.DivideExpression;
import TTMCConstraint.EnumerationLiteralDefinition;
import TTMCConstraint.EnumerationLiteralExpression;
import TTMCConstraint.EnumerationTypeDefinition;
import TTMCConstraint.EqualExpression;
import TTMCConstraint.EqualityExpression;
import TTMCConstraint.ExistsExpression;
import TTMCConstraint.FalseExpression;
import TTMCConstraint.FieldAssignment;
import TTMCConstraint.FieldDeclaration;
import TTMCConstraint.FinallyExpression;
import TTMCConstraint.ForallExpression;
import TTMCConstraint.FunctionAccessExpression;
import TTMCConstraint.FunctionDeclaration;
import TTMCConstraint.FunctionLiteralExpression;
import TTMCConstraint.FunctionTypeDefinition;
import TTMCConstraint.GloballyExpression;
import TTMCConstraint.GreaterEqualExpression;
import TTMCConstraint.GreaterExpression;
import TTMCConstraint.IfThenElseExpression;
import TTMCConstraint.ImplyExpression;
import TTMCConstraint.InExpression;
import TTMCConstraint.InequalityExpression;
import TTMCConstraint.IntegerLiteralExpression;
import TTMCConstraint.IntegerTypeDefinition;
import TTMCConstraint.LessEqualExpression;
import TTMCConstraint.LessExpression;
import TTMCConstraint.LetDeclaration;
import TTMCConstraint.LetExpression;
import TTMCConstraint.ModExpression;
import TTMCConstraint.MultiplyExpression;
import TTMCConstraint.NaturalTypeDefinition;
import TTMCConstraint.NextExpression;
import TTMCConstraint.NotExpression;
import TTMCConstraint.OrExpression;
import TTMCConstraint.ParameterDeclaration;
import TTMCConstraint.PrimedExpression;
import TTMCConstraint.RationalLiteralExpression;
import TTMCConstraint.RealTypeDefinition;
import TTMCConstraint.RecordAccessExpression;
import TTMCConstraint.RecordLiteralExpression;
import TTMCConstraint.RecordTypeDefinition;
import TTMCConstraint.ReferenceExpression;
import TTMCConstraint.ReleaseExpression;
import TTMCConstraint.SubTypeDefinition;
import TTMCConstraint.SubrangeTypeDefinition;
import TTMCConstraint.SubtractExpression;
import TTMCConstraint.TTMCConstraintPackage;
import TTMCConstraint.TemporalExistsExpression;
import TTMCConstraint.TemporalForallExpression;
import TTMCConstraint.TrueExpression;
import TTMCConstraint.TupleAccessExpression;
import TTMCConstraint.TupleLiteralExpression;
import TTMCConstraint.TupleTypeDefinition;
import TTMCConstraint.TypeDeclaration;
import TTMCConstraint.TypeReference;
import TTMCConstraint.UnaryMinusExpression;
import TTMCConstraint.UnaryPlusExpression;
import TTMCConstraint.UntilExpression;
import TTMCHybrid.Assignment;
import TTMCHybrid.ClockTypeDefinition;
import TTMCHybrid.DotExpression;
import TTMCHybrid.FlowCondition;
import TTMCHybrid.GlobalVariableDeclaration;
import TTMCHybrid.HybridAutomatonDeclaration;
import TTMCHybrid.HybridAutomatonDefinition;
import TTMCHybrid.HybridSpecification;
import TTMCHybrid.InitialCondition;
import TTMCHybrid.InvariantCondition;
import TTMCHybrid.LocalVariableDeclaration;
import TTMCHybrid.Location;
import TTMCHybrid.LocationReferenceExpression;
import TTMCHybrid.PropertyDeclaration;
import TTMCHybrid.TTMCHybridPackage;
import TTMCHybrid.Transition;
import com.google.inject.Inject;
import com.google.inject.Provider;
import hu.bme.mit.inf.ttmc.constraint.language.serializer.TTMCConstraintLanguageSemanticSequencer;
import hu.bme.mit.inf.ttmc.hybrid.language.services.TTMCHybridLanguageGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TTMCHybridLanguageSemanticSequencer extends TTMCConstraintLanguageSemanticSequencer {

	@Inject
	private TTMCHybridLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == TTMCConstraintPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TTMCConstraintPackage.ADD_EXPRESSION:
				sequence_AdditiveExpression(context, (AddExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (ArrayAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_LITERAL_EXPRESSION:
				sequence_ArrayLiteralExpression(context, (ArrayLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ARRAY_TYPE_DEFINITION:
				sequence_ArrayTypeDefinition(context, (ArrayTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.BASIC_CONSTRAINT_DEFINITION:
				sequence_BasicConstraintDefinition(context, (BasicConstraintDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.BOOLEAN_TYPE_DEFINITION:
				sequence_BooleanTypeDefinition(context, (BooleanTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.CONSTANT_DECLARATION:
				sequence_ConstantDeclaration(context, (ConstantDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.CONSTRAINT_SPECIFICATION:
				sequence_ConstraintSpecification(context, (ConstraintSpecification) semanticObject); 
				return; 
			case TTMCConstraintPackage.DECIMAL_LITERAL_EXPRESSION:
				sequence_DecimalLiteralExpression(context, (DecimalLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.DIV_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.DIVIDE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivideExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_LITERAL_DEFINITION:
				sequence_EnumerationLiteralDefinition(context, (EnumerationLiteralDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_LITERAL_EXPRESSION:
				sequence_EnumerationLiteralExpression(context, (EnumerationLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.ENUMERATION_TYPE_DEFINITION:
				sequence_EnumerationTypeDefinition(context, (EnumerationTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.EQUAL_EXPRESSION:
				sequence_EqualExpression(context, (EqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.EQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.EXISTS_EXPRESSION:
				sequence_ExistsExpression(context, (ExistsExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FALSE_EXPRESSION:
				sequence_FalseExpression(context, (FalseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FIELD_ASSIGNMENT:
				sequence_FieldAssignment(context, (FieldAssignment) semanticObject); 
				return; 
			case TTMCConstraintPackage.FIELD_DECLARATION:
				sequence_FieldDeclaration(context, (FieldDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.FINALLY_EXPRESSION:
				sequence_FinallyExpression(context, (FinallyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FORALL_EXPRESSION:
				sequence_ForallExpression(context, (ForallExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (FunctionAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_LITERAL_EXPRESSION:
				sequence_FunctionLiteralExpression(context, (FunctionLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.FUNCTION_TYPE_DEFINITION:
				sequence_FunctionTypeDefinition(context, (FunctionTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.GLOBALLY_EXPRESSION:
				sequence_GloballyExpression(context, (GloballyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.GREATER_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterEqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.GREATER_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IF_THEN_ELSE_EXPRESSION:
				sequence_IfThenElseExpression(context, (IfThenElseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IMPLY_EXPRESSION:
				sequence_ImplyExpression(context, (ImplyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.IN_EXPRESSION:
				sequence_InExpression(context, (InExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INEQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (InequalityExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INTEGER_LITERAL_EXPRESSION:
				sequence_IntegerLiteralExpression(context, (IntegerLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.INTEGER_TYPE_DEFINITION:
				sequence_IntegerTypeDefinition(context, (IntegerTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.LESS_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (LessEqualExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.LESS_EXPRESSION:
				sequence_ComparisionExpression(context, (LessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.LET_DECLARATION:
				sequence_LetDeclaration(context, (LetDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.MOD_EXPRESSION:
				sequence_MultiplicativeExpression(context, (ModExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.MULTIPLY_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplyExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.NATURAL_TYPE_DEFINITION:
				sequence_NaturalTypeDefinition(context, (NaturalTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.NEXT_EXPRESSION:
				sequence_NextExpression(context, (NextExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.PRIMED_EXPRESSION:
				sequence_AccessExpression(context, (PrimedExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RATIONAL_LITERAL_EXPRESSION:
				sequence_RationalLiteralExpression(context, (RationalLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.REAL_TYPE_DEFINITION:
				sequence_RealTypeDefinition(context, (RealTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (RecordAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_LITERAL_EXPRESSION:
				sequence_RecordLiteralExpression(context, (RecordLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RECORD_TYPE_DEFINITION:
				sequence_RecordTypeDefinition(context, (RecordTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.REFERENCE_EXPRESSION:
				sequence_ReferenceExpression(context, (ReferenceExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.RELEASE_EXPRESSION:
				sequence_ReleaseExpression(context, (ReleaseExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUB_TYPE_DEFINITION:
				sequence_SubTypeDefinition(context, (SubTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUBRANGE_TYPE_DEFINITION:
				sequence_SubrangeTypeDefinition(context, (SubrangeTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.SUBTRACT_EXPRESSION:
				sequence_AdditiveExpression(context, (SubtractExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TEMPORAL_EXISTS_EXPRESSION:
				sequence_TemporalExistsExpression(context, (TemporalExistsExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TEMPORAL_FORALL_EXPRESSION:
				sequence_TemporalForallExpression(context, (TemporalForallExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TRUE_EXPRESSION:
				sequence_TrueExpression(context, (TrueExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (TupleAccessExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_LITERAL_EXPRESSION:
				sequence_TupleLiteralExpression(context, (TupleLiteralExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.TUPLE_TYPE_DEFINITION:
				sequence_TupleTypeDefinition(context, (TupleTypeDefinition) semanticObject); 
				return; 
			case TTMCConstraintPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case TTMCConstraintPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNARY_MINUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryMinusExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNARY_PLUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryPlusExpression) semanticObject); 
				return; 
			case TTMCConstraintPackage.UNTIL_EXPRESSION:
				sequence_UntilExpression(context, (UntilExpression) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == TTMCHybridPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TTMCHybridPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case TTMCHybridPackage.CLOCK_TYPE_DEFINITION:
				sequence_ClockTypeDefinition(context, (ClockTypeDefinition) semanticObject); 
				return; 
			case TTMCHybridPackage.DOT_EXPRESSION:
				sequence_SignumExpression(context, (DotExpression) semanticObject); 
				return; 
			case TTMCHybridPackage.FLOW_CONDITION:
				sequence_FlowCondition(context, (FlowCondition) semanticObject); 
				return; 
			case TTMCHybridPackage.GLOBAL_VARIABLE_DECLARATION:
				sequence_GlobalVariableDeclaration(context, (GlobalVariableDeclaration) semanticObject); 
				return; 
			case TTMCHybridPackage.HYBRID_AUTOMATON_DECLARATION:
				sequence_HybridAutomatonDeclaration(context, (HybridAutomatonDeclaration) semanticObject); 
				return; 
			case TTMCHybridPackage.HYBRID_AUTOMATON_DEFINITION:
				sequence_HybridAutomatonDefinition(context, (HybridAutomatonDefinition) semanticObject); 
				return; 
			case TTMCHybridPackage.HYBRID_SPECIFICATION:
				sequence_HybridSpecification(context, (HybridSpecification) semanticObject); 
				return; 
			case TTMCHybridPackage.INITIAL_CONDITION:
				sequence_InitialCondition(context, (InitialCondition) semanticObject); 
				return; 
			case TTMCHybridPackage.INVARIANT_CONDITION:
				sequence_InvariantCondition(context, (InvariantCondition) semanticObject); 
				return; 
			case TTMCHybridPackage.LOCAL_VARIABLE_DECLARATION:
				sequence_LocalVariableDeclaration(context, (LocalVariableDeclaration) semanticObject); 
				return; 
			case TTMCHybridPackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case TTMCHybridPackage.LOCATION_REFERENCE_EXPRESSION:
				sequence_LocationReferenceExpression(context, (LocationReferenceExpression) semanticObject); 
				return; 
			case TTMCHybridPackage.PROPERTY_DECLARATION:
				sequence_PropertyDeclaration(context, (PropertyDeclaration) semanticObject); 
				return; 
			case TTMCHybridPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (lhs=Expression rhs=Expression)
	 */
	protected void sequence_Assignment(EObject context, Assignment semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.ASSIGNMENT__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.ASSIGNMENT__LHS));
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.ASSIGNMENT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.ASSIGNMENT__RHS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignmentAccess().getLhsExpressionParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAssignmentAccess().getRhsExpressionParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {ClockTypeDefinition}
	 */
	protected void sequence_ClockTypeDefinition(EObject context, ClockTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_FlowCondition(EObject context, FlowCondition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.CONDITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFlowConditionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_GlobalVariableDeclaration(EObject context, GlobalVariableDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGlobalVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGlobalVariableDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? hybridAutomaton=HybridAutomaton)
	 */
	protected void sequence_HybridAutomatonDeclaration(EObject context, HybridAutomatonDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((variableDeclarations+=VariableDeclaration | locations+=Location | transitions+=Transition)*)
	 */
	protected void sequence_HybridAutomatonDefinition(EObject context, HybridAutomatonDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         (
	 *             typeDeclarations+=TypeDeclaration | 
	 *             functionDeclarations+=FunctionDeclaration | 
	 *             constantDeclarations+=ConstantDeclaration | 
	 *             basicConstraintDefinitions+=BasicConstraintDefinition | 
	 *             hybridAutomatonDeclarations+=HybridAutomatonDeclaration | 
	 *             propertyDeclarations+=PropertyDeclaration
	 *         )*
	 *     )
	 */
	protected void sequence_HybridSpecification(EObject context, HybridSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_InitialCondition(EObject context, InitialCondition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.CONDITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInitialConditionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_InvariantCondition(EObject context, InvariantCondition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.CONDITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvariantConditionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_LocalVariableDeclaration(EObject context, LocalVariableDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLocalVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalVariableDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     location=[Location|ID]
	 */
	protected void sequence_LocationReferenceExpression(EObject context, LocationReferenceExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.LOCATION_REFERENCE_EXPRESSION__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.LOCATION_REFERENCE_EXPRESSION__LOCATION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLocationReferenceExpressionAccess().getLocationLocationIDTerminalRuleCall_1_0_1(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID conditions+=Condition*)
	 */
	protected void sequence_Location(EObject context, Location semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID hybridAutomaton=HybridAutomaton expression=Expression)
	 */
	protected void sequence_PropertyDeclaration(EObject context, PropertyDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.PROPERTY_DECLARATION__HYBRID_AUTOMATON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.PROPERTY_DECLARATION__HYBRID_AUTOMATON));
			if(transientValues.isValueTransient(semanticObject, TTMCHybridPackage.Literals.PROPERTY_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCHybridPackage.Literals.PROPERTY_DECLARATION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPropertyDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyDeclarationAccess().getHybridAutomatonHybridAutomatonParserRuleCall_3_0(), semanticObject.getHybridAutomaton());
		feeder.accept(grammarAccess.getPropertyDeclarationAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=SignumExpression
	 */
	protected void sequence_SignumExpression(EObject context, DotExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSignumExpressionAccess().getOperandSignumExpressionParserRuleCall_2_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=SignumExpression
	 */
	protected void sequence_SignumExpression(EObject context, UnaryMinusExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSignumExpressionAccess().getOperandSignumExpressionParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     operand=SignumExpression
	 */
	protected void sequence_SignumExpression(EObject context, UnaryPlusExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TTMCConstraintPackage.Literals.UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSignumExpressionAccess().getOperandSignumExpressionParserRuleCall_1_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         source=[Location|ID] 
	 *         target=[Location|ID] 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         (guards+=Expression guards+=Expression*)? 
	 *         (assignments+=Assignment assignments+=Assignment*)?
	 *     )
	 */
	protected void sequence_Transition(EObject context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
